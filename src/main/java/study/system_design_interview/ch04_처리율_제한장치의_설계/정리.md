# 처리율 제한 장치 (Rate Limiter)

처리율 제한 장치(Rate Limiter)는 **시간 단위당 요청 개수를 제한**하여 시스템을 보호하는 장치다.

## 왜 필요한가
- **서비스 안정성**: DoS 공격, 크롤러 등으로 인한 과부하 방지
- **비용 절감**: 무분별한 API 호출 억제

## 고려 사항
- **적용 위치**
  - 클라이언트, 미들웨어, 서버 등
- **단위**
  - 사용자별, IP별, API 키별
- **분산 환경**
  - 여러 서버에서 동시 처리 시 **일관성 유지**가 필요
  - 중앙 저장소 활용


## 구현 알고리즘

### 토큰 버킷

많은 기업들이 보편적으로 사용하는 알고리즘(ex: AWS API GATEWAY)  
통상적으로 API 엔드포인트마다 별도의 버킷을 둔다.

- **동작**
  - 버킷에 **일정 속도로 토큰이 채워짐**
  - 요청 시 토큰 소비, 토큰이 없으면 요청은 버려짐
- **인자**
  - 버킷 크기, 토큰 공급률
- **장점**
  - 구현이 쉽다.
  - 메모리 효율적
  - 순간적인 버스트 트래픽 허용
- **단점**:
  - 매개변수 튜닝이 까다롭다.

### 누출 버킷

토큰 버킷과 유사하지만, **요청 처리율이 고정**된다는 차이가 있다.  
보통 FIFO 큐로 구현된다.

- **동작**
  - 요청이 들어오면 큐의 상태를 체크
  - 빈 자리가 있다면 큐에 추가, 큐가 가득차 있다면 요청은 버림
  - 지정된 시간마다 큐에서 요청을 꺼내서 처리
- **장점**
  - 고정된 처리율
- **단점**
  - 단시간에 트래픽이 몰리는 경우 최신 요청들이 버려지게 됨

### 고정 윈도 카운터

- **동작**
  - 일정 구간(예: 1분)에 카운터를 두고 횟수 제한
- **장점**
  - 단순하고 이해하기 쉽다
- **단점**
  - **경계 문제**존재
    - 예: 59초에 100번, 60초에 100번 요청 -> 사실상 순간 200번 허용

### 이동 윈도 로깅

- **동작**
  - 각 요청의 타임스탬프를 로그로 저장
  - 최근 N초 범위의 요청만 카운트하여 제한
- **장점**
  - 고정 윈도 카운터의 경계 문제 완화,
- **단점**
  - 모든 요청의 타임스탬프를 저장해야 하므로 **메모리 사용량이 많다**

### 이동 윈도 카운터

고정 윈도 카운터 + 이동 윈도 로깅  
현재 1분간의 요청 수 + 직전 1분간의 요청 수 X 이동 윈도와 직전 1분이 겹치는 비율

- **동작**
  - 작은 단위 구간으로 나누어 카운트 관리
  - 현재 구간과 직전 구간의 비율을 계산하여 추정
- **장점**
  - 메모리 효율적
  - 짧은 시간에 몰리는 트래픽에도 잘 대응
- **단점**
  - 근사치 기반이므로 **정확도가 완벽하지 않음**
  - 하지만 클라우드플레어에서 진행한 실험에 의하면 오탐은 0.003%에 불과


## 처리율 제한 규칙

### 처리율 한도 초과 트래픽 처리
- 보통 **HTTP 429 (Too Many Requests)** 반환
- 필요 시 초과 요청을 별도 큐에 보관 후 지연 처리 가능

### 처리율 제한 장치가 사용하는 HTTP 헤더
클라이언트가 제한 상태를 인지할 수 있도록 제공한다.

- `X-Ratelimit-Remaining`: 윈도 내에 남은 처리 가능 요청의 수
- `X-Ratelimit-Limit`: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
- `X-Ratelimit-Retry-After`: 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지 알림


## 경쟁 조건(Race Condition)

동시에 여러 요청이 카운터를 증가시키면 **허용 횟수 초과**가 발생할 수 있다.  
중앙 저장소(예: Redis)에서 **원자적 연산**으로 **체크-증가-만료를 한 덩어리로 처리**해야 한다.

### Redis의 sorted set
- 점수(`score`)와 값(`member`)을 함께 저장하는 정렬된 집합.
- `score` 기준으로 자동 정렬, 범위 검색이 빠름
- 요청 타임스탬프를 `score`로 저장하면 **최근 N초 요청만 집계** 가능
  - **롤링 윈도우(rate limit)** 구현에 적합

### 루아 스크립트 사용
- Redis는 단일 명령은 원자적, 하지만 여러 명령을 나눠 보내면 중간에 끼어들 수 있음.
- Lua 스크립트는 여러 연산을 **하나의 명령처럼 실행**하므로 실행 도중 다른 요청이 끼어들 수 없다.
- 장점
  - 원자성 보장
  - 네트워크 왕복(RTT) 감소




