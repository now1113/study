# SQL 쿼리/튜닝 정리

## 목차

1. SQL 실행 구조 및 내부 처리 과정
2. MySQL 쿼리 내부 실행 순서 (FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT)
3. 실행 계획(EXPLAIN) 분석 및 이해
4. 인덱스 기초 및 효율적 설계 전략 (카디널리티, 선택도, 복합인덱스 등)
5. 인덱스가 타는 쿼리 vs 안 타는 쿼리 분석
6. 조인(JOIN)의 종류와 동작 원리 (Inner/Outer/Cross)
7. 서브쿼리 vs 조인 성능 분석 및 최적화
8. 윈도우 함수(Window Function) 사용법과 활용 예제
9. 느린 쿼리/풀스캔 분석 및 병목 해소 방법
10. 최적화 사례 Q&A (심화)


## 1. SQL 실행 구조 및 내부 처리 과정

### 전체 실행 흐름 요약

```text
[Client] -> [Parser] -> [Optimizer] -> [Executor] -> [Buffer Pool / Storage Engine]
```

#### Parser (SQL 파서)
- SQL 문장을  파싱하여 **구문 트리(Syntax Tree)** 생성
- **문업 오류 체크** 수행
- `SELECT * FROM user WHERE id = 1` -> SELECT 노드, FROM 노드 등으로 구조화

#### Preprocessor (전처리기)
- **권한 검사** (해당 테이블/컬럼 조회 권한)
- **객체 존재 여부**확인 (`user` 테이블이 실제 존재하는가 등)

#### Optimizer (옵티마이저)
- **실행 계획(Execution Plan) 수립**
- 여러 가지 실행 전략 중 **가장 비용이 적은 경로(Cost-Based)** 선택
  - ex) Index Scan vs Full Scan
- 조건절 순서/조인 순서도 이 단계에서 최적화

#### Executor (실행기)
- 옵티마이저가 만든 실행 계획을 기반으로 실제 데이터 액세스
- 필요한 데이터를 읽어오고 결과 반환

#### Buffer Pool / Storage Engine
- **Buffer Pool**: 자주 조회되는 데이터를 메모리에 캐싱
- **Storage Engine**: InnoDB, MyISAM 등 실제 데이터 저장/조회 구현


### MySQL 내부 흐름 

```text
  [Client SQL 요청]
          ↓
   ┌────────────────────┐
   │      Parser        │ ← 문법 분석, 트리 생성
   └────────────────────┘
          ↓
   ┌────────────────────┐
   │   Preprocessor     │ ← 권한/객체 존재 확인
   └────────────────────┘
          ↓
   ┌────────────────────┐
   │     Optimizer      │ ← 실행계획 수립
   └────────────────────┘
          ↓
   ┌────────────────────┐
   │     Executor       │ ← 실행 계획 수행
   └────────────────────┘
          ↓
   ┌──────────────────────────────┐
   │ Buffer Pool / Storage Engine │ ← 데이터 캐시/실제 저장소
   └──────────────────────────────┘
```

### Query Cache (MySQL 5.x까지)
> 동일한 SELECT 쿼리 결과를 메모리에 캐시해두고, 동일 요청이 오면 결과만 반환  
> -> 다시 실행하지 않고 결과만 꺼내서 빠르게 반환 가능

#### 동작 방식
- 쿼리 문자열이 **완전히 동일**해야 함(`공백/대소문자까지 포함`)
- 해당 쿼리에 사용된 **테이블이 변경(INSERT/UPDATE/DELETE)되면 자동으로 캐시가 무효화됨(Flush)**

#### 문제점
- 캐시된 쿼리는 빠르지만, **테이블이 변경될 때마다 전부 무효화**
- 트래픽 많은 환경에서 오히려 **캐시 유지/갱신 오버헤드가 커짐**
- **병목과 락 경합**이 발생 -> 성능 저하

#### 그래서 MySQL 8.0에서 제거됨
- 실질적으로 도움이 되는 경우가 거의 없고
- **InnoDB 버퍼 풀, 쿼리 플랜 캐시, 응용단 캐시**가 더 효율적이었기 때문에 폐지됨

### 정리
| 단계           | 설명                                          | 실무에서 체크포인트                     |
|--------------|---------------------------------------------|--------------------------------------|
| Parser       | SQL 문법 검사 및 구조화                              | 쿼리 구조가 복잡한 경우 성능 저하 발생 가능         |
| Preprocessor | 권한 및 객체 존재 확인                                | 권한 없으면 에러 발생 (EXPLAIN 안 되는 경우 있음) |
| Optimizer    | 최적의 실행계획 수립 (인덱스 사용 여부, 조인 순서 등 판단)         | **EXPLAIN** 분석으로 확인 가능            |
| Executor     | 실행계획에 따라 쿼리 실행                                 | 실제 성능 문제는 대부분 이 단계에서 발생        |
| Storage      | Buffer Pool을 통해 디스크 I/O 최소화, 실제 데이터 액세스 수행 | Buffer Pool이 작으면 I/O 증가           |

### Q&A

#### SQL 쿼리가 실제 실행되는 전체 과정은?
Parser -> Preprocessor -> Optimizer -> Executor -> Storage 순으로 진행되며,  
실행계획은 옵티마이저가 결정하고 실제 데이터는 Executor가 가져온다.  
Buffer Pool이 캐싱 역할을 해 I/O를 줄인다.

#### Optimizer는 어떤 기준으로 실행 계획을 선택할까?
Cost-Based 방식으로 **전체 비용(읽을 행 수, 인덱스 사용 여부 등)을 계산해** 가장 효율적인 실행 경로를 선택한다.

#### Buffer Pool이 없으면 어떤 문제가 발생할까
모든 데이터를 디스크에서 직접 읽기 때문에 성능이 급격히 저하된다. 특히 자주 조회되는 데이터는 캐싱 효과가 크다.