:trophy: 이펙티브 자바 스터디 - 아이템 46

:book: 아이템 46: 스트림에서는 부작용 없는 함수를 사용하라

## 핵심
- **스트림에서는 외부 상태 변경(부작용, side effect)없는 순수 함수형 코드**를 작성해야 한다.
- 집계/변환/분류 등 모든 연산을 **Collectors(collect, groupingBy, toMap, counting 등)로 처리해야 코드가 안전하고 병렬 처리에도 문제 없이 동작한다.**
- forEach에서 외부 컬렉션/변수 변경은 절대 피하라.


## 잘못된 예시와 문제점

### [잘못된 예시] forEach에서 외부 Map 변경 (side effect)

```java
private static final List<String> words = List.of("ab", "abc", "cde");

Map<String, Long> freq = new HashMap<>();
words.forEach(word -> {
    freq.merge(word.toLowerCase(), 1L, Long::sum);
});
```
- 스트림의 함수형 패러다임(불변성, 순수성)을 해침
- 병렬 처리(parallelStream)시 race condition 발생
- 결과가 예측 불가, 버그/디버깅 어려움

## Collector API별 예시

### groupingBy: 분류/집계
```java
Map<Integer, List<String>> wordsByLength = words.stream()
        .collect(Collectors.groupingBy(String::length));
```

### groupingBy + counting: 분류 + 개수 세기
```java
Map<Integer, Long> countByLength = words.stream()
    .collect(Collectors.groupingBy(String::length, Collectors.counting()));
```

### groupingBy + mapping: 분류 + 값 가공 + 수집
```java
// 단어 길이별 첫 글자만 모으기
Map<Integer, Set<Character>> initialByLength = words.stream()
    .collect(Collectors.groupingBy(
        String::length,
        Collectors.mapping(w -> w.charAt(0), Collectors.toSet())
    ));
```

### toMap: 직접 Map 만들기 (키 중복 주의)
```java
// 단어 -> 길이 Map, 키 중복 발생 시 예외
Map<String, Integer> wordLength = words.stream()
    .collect(Collectors.toMap(
        w -> w,                
        String::length         
    ));
```
> 키 중복 허용하려면 merge 함수 추가
```java
Map<Integer, String> sample = Stream.of("a", "bb", "cc")
    .collect(Collectors.toMap(
        String::length,            
        w -> w,                     
        (s1, s2) -> s1 + "," + s2    
    ));
// {1="a", 2="bb,cc"}
```

### reducing: 누적/합산/최대/최소
```java
Integer totalLength = words.stream()
        .map(String::length)
        .reduce(0, Integer::sum);
System.out.println(totalLength);
```

### collectingAndThen: 후처리
```java
// 단어 길이별 목록의 불변 리스트로 변환
Map<Integer, List<String>> immutableLists = words.stream()
    .collect(Collectors.groupingBy(
        String::length,
        Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)
    ));
```


## 정리

### groupingBy와 toMap의 차이
- groupngBy는 **여러 값이 같이 키에 그룹핑** (key->List/Set/Map 등)
- toMap은 **각 key에 하나의 value만 매핑**, 중복 키는 예외 또는 merge 필요

### counting(), mapping(), reducing() 등 Collector 조합은 언제 사용할까
- 집계(갯수): counting()
- 그룹 내 값 변환 후 수집: mapping()
- 누적/최종값: reducing()
- 집계 후 후처리: collectingAndThen()

### side effect 없는 함수로만 처리해야 하는 이유는 뭘까
- 병렬 스트림(parallelStream)에서 안전
- 코드 예측 가능/테스트 쉬움
- 가독성/확장성 증가

### 꼭 side effect(로깅 등)가 필요하면?
- 스트림/Collector 로직과 분리된 루프에서 처리하는게 안전.

### stream/collect는 성능에도 좋은가?
- 병렬 처리/배치 연산에서 유리
- 단순 루프보다 항상 빠른 건 아님
- **가독성, 확장성, 안정성**이 제일 큰 장점

> Collector API를 적극적으로 활용해서  
> 부작용 없는 함수형 코드로 집계/변환/분류/후처리까지 **한번에 처리**하자  
> 외부 상태 변경은 절대로 지양