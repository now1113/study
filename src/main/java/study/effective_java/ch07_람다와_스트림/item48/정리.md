:trophy: 이펙티브 자바 스터디 - 아이템 48

:book: 아이템 48: 스트림 병렬화는 주의해서 적용하라

## 핵심
- **무턱대고** `parallel()` **쓰지 말 것.**, 병렬 스트림은 잘못 쓰면 느려지거나 오답이 나올 수 있다.
- 병렬화가 효과를 내려면 **다음이 모두 유리해야 함.**
  - **CPU-bound** 연산(블로킹 I/O 없음)
  - **데이터 소스 분할이 용이**(좋은 Spliterator)
  - **연산이 순수/무상태/결합법칙(associative)** 만족
  - **입력 데이터가 충분히 큼**(오버헤드 상쇄)
- 기본 스레드풀은 `ForkJoinPool.commonPool()` **공유**이므로 서비스 전체와 리소스를 경합한다. 남용 시 다른 작업에 악영향


## 언제 병렬이 잘 먹힐까?

- **데이터 소스**가 배열, `ArrayList`, `HashMap/HashSet`, `ConcurrentHashMap`, 원시 범위(`IntStream.range.*`)처럼 **균등 분할**이 쉬울 때
- **연산 비용이 충분히 큰 CPU 작업** ex) 수치 계산, 해싱/암호화 같은 무거운 반환
- **무상태, 비간섭(non-interfering)** 중간 연산과 **결합법칙 만족** 최종 연산(`reduce`, 병렬 친화 Collector)일 때
- **순서 의존이 낮을수록 유리**(`forEach` > `forEachOrdered`, 가능하면 `.unordered()`

> 반대로 `Stream.iterate`, `LinkedList`, **I/O, 네트워크, DB 커서** 기반, **짧은 파이프라인**은 병렬 이득이 거의 없음


## 대표 함정과 대책

### 1) `forEach`로 외부 상태 변경

```java
// 외부 리스트 변경 -> 경쟁 조건
private static void parallelForEach() {
    List<String> names = new ArrayList<>();
    List<Member> members = new ArrayList<>();
    
    members.parallelStream()
            .map(Member::getName)
            .forEach(names::add);
}
```

#### 대책

```java
// 수집기로 병렬 안전 처리
private static void parallelForEachSolve() {
    List<Member> members = new ArrayList<>();

    List<String> names = members.parallelStream()
            .map(Member::getName)
            .toList();
}
```


### 결합법칙 어기는 reduce

> 결합 법칙은 연산의 순서에 상관없이 동일한 결과를 얻을 수 있다는 것을 의미

```java
// 누적자에 부수효과 포함(문자열 이어붙이지 + 외부 상태 가정)
private static void parallelReduce() {
  members.parallelStream()
          .map(Member::getName)
          .reduce("", (a, b) -> a + b); // 비효율 + 결합법칙 위배 가능
}
```

#### 대책

```java
private static void parallelReduceSolve() {
    members.parallelStream()
            .map(Member::getName)
            .collect(Collectors.joining());
}
```
> `reduce`는 **결합법칙**을 만족하는 연산에만(합계/최대값 등) 사용.


### `Stream.iterate` 병렬화

```java
private static void parallelStreamIterate() {
    int sum = Stream.iterate(0, i -> i + 1)
            .limit(1_000_000)
            .parallel()
            .reduce(0, Integer::sum);         // 박싱/언박싱 발생, combiner 비용 큼
}
```

#### 대안

```java
private static void parallelStreamIterateSolve() {
    // 범위 스트림은 SIZED/SUBSIZED 분할이 좋아 병렬 친화적
    LongStream.rangeClosed(1, 1_000_000)
            .parallel()
            .sum();
}
```

### 순서 강제 연산 (`forEachOrdered`)

```java
// 순서 보장이 필요한 연산은 병렬 성능 이점이 급감
list.parallelStream().forEachOrdered(this::handle);
```

**대책**: 순서가 중요하면 **그냥 순차**가 낫고, 중요치 않다면 `.unordered()`로 힌트

```java
list.parallelStream().unordered().forEach(this::handle);
```

## Member 예제

### 등급별 집계

```java
// 순차/병렬 모두 안전
public Map<MemberGrade, Long> getMemberMap() {
    List<Member> members = new ArrayList<>();

    return members.parallelStream()
            .collect(Collectors.groupingBy(
                    Member::getGrade,
                    () -> new EnumMap<>(MemberGrade.class),
                    Collectors.counting()
            ));
}
```

### 병렬 대용량에서 더 빠를 수 있는 concurrent 수집기

```java
// encounter order 불필요 -> 병렬 집계의 유리
public Map<MemberGrade, Long> getMemberMapByConcurrent() {
    List<Member> members = new ArrayList<>();

    return members.parallelStream()
            .unordered()
            .collect(Collectors.groupingByConcurrent(
                    Member::getGrade,
                    ConcurrentHashMap::new,
                    Collectors.counting()
            ));
}
```
- `groupingByConcurrent`는 **unordered**일 때 이점 큼.
- 순서가 필요하면 일반 `groupingBy` 사용.

## 언제 병렬을 사용할까?

### 병렬 고려 (효과 기대)
- 데이터가 수백만 건이고, **CPU-heavy** 파이프라인 ex) 복잡한 유효성 검증 + 해시 계산
- 소스가 `ArrayList`/배열/`ConcurrentHashMap`/`IntStream.range`
- 결과가 큰 집계: `groupingByConcurrent`, `toConcurrentMap` 등 병렬 친화 Collector

### 병렬 비권장 (순차 유지)
- JPA 엔티티 접근, DB 호출, REST 호출, 파일 I/O 포함(블로킹)
- `Stream.iterate`, `LinkedList` 짧고 가벼운 연산
- 순서가 중요한 파이프라인 (`forEachOrdered`, `findFirst`)
- 사이드 이펙트(외부 상태 변경)가 필요한 경우

## 주의점

### 공용 스레드풀 주의
- 병렬 스트림은 기본적으로 **공유** `ForkJoinPool.commonPool()` 사용.
- 대량 병렬 스트림이 돌면 **다른 요청/스케쥴러**가 영향을 받음.
- 특정 작업만 병렬화가 꼭 필요하면
  - **별도 Executor/ForkJoinPool**에서 **배치 작업**으로 처리하거나
  - 아예 **스트림 병렬** 대신 **명시적 병렬 처리**(CompletableFuture 등) 고려.

> 스트림 병렬은 **컨트롤 하기 어려운 전역 자원**을 쓴다는점을 기억하자.

## 팁
- **박싱 비용** 줄이기: `mapToInt/mapToLong`등 원시 스트림 활용.
- `.peek()`로 **디버깅 금지**(병렬에서 로그 순서 난리남). 꼭 필요하면 임시로만 사용
- 병렬 성능 측정은 **JMH** 같은 마이크로벤치 실제 수치 확인(감으로 절대 판단 금지)

## 요약

### `groupingBy` vs `groupingByConcurrent` 차이
- 둘 다 병렬에서 동작하지만 `groupingBytConcurrent`는 **동시 업데이트**에 최적화된 `ConcurrentHashMap` 사용
- **순서가 필요 없는 대용량 집계**에서 더 유리.

### 병렬 스트림에서 안전한 `Collector`는 뭘까
- JDK 기본 수집기들은 병렬에 맞게 설계됨(스레드별 부분 결과를 만들고 합침)
- 다만 **직접 만든 Collector**라면 누적기/결합기가 **결합법칙, 무상태**를 만족해야 함

### 병렬화 임계점은
- 데이터 크기, 연산, 비용, 머신 코어 수에 따라 다름. **작으면 대부분 손해**. 반드시 측정 해야함

### I/O가 섞이면?
- 병렬 스트림으로는 비권장. 차라리 **비동기/리액티브** 또는 **전용 스레드풀**이 낫다.

> **병렬 스트림은 조건이 맞을 때만 신중히 사용하자**  
> 좋은 분할 소스(+ 충분한 데이터), 순수/결합법칙 연산, 순서 비의존, CPU-bound라면 이득.  
> 그 외엔 순차가 대체로 안전하고, 성능도 낫다. **반드시 측정하고 결정하자.**