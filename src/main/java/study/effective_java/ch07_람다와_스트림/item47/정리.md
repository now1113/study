:trophy: 이펙티브 자바 스터디 - 아이템 47

:book: 아이템 47: 반환 타입으로는 스트림보다 컬렉션이 낫다

## 핵심
- **반환 타입은 가급적** `Collection`(또는 그 하위: `List`, `Set`)**로 제공**하라.
  - 클라이언트가 **for-each**도 쓰고 **stream()도 뽑아 쓸 수 있음**
- `Stream`은 **일회성, 소비성**이라 재사용/탐색/크기 계산이 어렵고 API 활용성도 떨어짐
- **컬렉션으로 만들기 어렵거나 부적절**(매우 크거나, 지연(lazy), 일회성 자원(close) 필요)한 경우에만 `Stream` 또는 `Iterable`을 고려하라
- 필요 시 **어댑터**를 제공해 `Iterable <-> Stream`간 전환을 쉽게 만들자.

## 왜 컬렉션이 더 좋을까
- `Collection`은 **크기(size), 비어 있음(isEmpty), 포함 여부(contains), 반복/다회 순회**가 자연스럽고,
- 곧바로 `Collection.stream()`으로 스트림 파이프라인도 구성 가능
- 반면 `Stream`은
  - 한 번 소비하면 **재사용 불가**(한 번 더 순회하려면 다시 만들어야 함)
  - `size`, `contains` 같은 **탐색 연산 부재**
  - 경우에 따라 **자원 관리(try-with-resources)가 필요할 수 있음** ex) 파일, DB 커서 기반 스트림

## 잘못된 예시 -> 개선 예시

> 공통 모델

```java
enum MemberGrade { BRONZE, SILVER, GOLD, PLATINUM }

class Member {
    private final String name;
    private final int age;
    private final MemberGrade grade;
}
```

### 잘못된 예시: 무조건 `Stream` 반환

```java
// 무조건 Stream으로 돌려주면 재사용/탐색 불가, 자원 닫기 이슈 가능
public Stream<Member> findAllStreamMembers() {
    // 클라이언트는 collect부터 강요됨
    List<Member> members = new ArrayList<>();
    return members.stream();
}

public List<Member> findAllStreamMembers() {
    Stream<Member> allMembers = memberService.findAllStreamMembers();

    // Stream은 한 번만 사용이 가능
//        long count = allMembers.count();

    // Stream을 바로 JSON으로 직렬화하지 못하니 바꿔줘야함.
    try (Stream<Member> members = allMembers) {
        return allMembers.toList();
    }
}
```

### 개선 예시: `List` 반환 + 필요 시 클라이언트가 `stream()` 호출

```java
public List<Member> findAllMembers() {
    List<Member> members = new ArrayList<>();
    return List.copyOf(members);
}

public void findAllMembers() {
    List<Member> all = memberService.findAllMembers();
    List<Integer> names = all.stream()
            .map(Member::getAge)
            .toList();
}
```

### 예외: 컬렉션으로 만들기 과도할 때만 `Stream/Iterable`
- **원소 갯수가 매우 큼 / 지연 계산 / IO, DB 커서 기반 / close 필요** 등:
  - `Stream` 반환 + **명확한 문서화**(일회성, try-with-resource로 닫으시오)
  - 또는 `Iterable` 반환(다회 순회가 가능해야 하고, 자원 누수 없게 설계)

```java
// DB 커서 기반 - 반드시 try-with-resources로 닫게 설계/문서화
public Stream<Member> streamByGrade(MemberGrade memberGrade) {
    // JPA/Hibernate의 ScrollableResult, JDBC ResultSet 등으로부터 Stream 구성했다고 가정
    return memberRepository.streamByGrade(memberGrade); // 문서에 close 필요 남기기
}

public void streamByGrade() {
    try (Stream<Member> s = memberService.streamByGrade(MemberGrade.GOLD)) {
        long count = s.filter(m -> m.getAge() >= 30).count();
    }
}
```

## 어댑터 (책에 나온 테크닉)

```java
public class Adapter {
    // Iterable -> Stream
    public static <T> Stream<T> streamOf(Iterable<T> iterable) {
        return StreamSupport.stream(iterable.spliterator(), false);
    }
    
    // Stream -> Iterable
    public static <T> Iterable<T> iterableOf(Stream<T> stream) {
        return stream::iterator;
    }
    
    // Iterator -> Stream (크기 미상)
    public static <T> Stream<T> streamOf(Iterator<T> iterator) {
        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, 0), false);
    }
}
```

## 정리
- **기본 원칙**: 반환은 `Collection` 먼저, 곤란하면 `Stream`/`Iterable`
- **불변 컬렉션**을 선호: `List.copyOf()`, `Set.copyOf()`, `Collections.unmodifiable*`
- **너무 큰 결과**를 한 번에 컬렉션으로 만드는 게 위험하면 **페이징(Page/Slice)** 을 고려
- `Stream`을 반환할 때는 **일회성/자원관리**를 자바독에 굵게 명시
- 내부 계산을 **뷰 컬렉션(AbstractList 등)** 으로 제공하면, 메모리를 덜 쓰면서도 `Collection` API를 살릴 수 있음(필요 시)


| 반환 타입        | 장점                                                  | 단점/주의                                   | 쓰임새     |
| ------------ | --------------------------------------------------- | --------------------------------------- | ------- |
| `Collection` | 다회 순회, `size/contains`, for-each + `stream()` 모두 가능 | 큰 결과 전부 적재 시 메모리 부담                     | **기본값** |
| `Stream`     | 지연·일회성·대량 처리/IO 커서와 궁합, 파이프라인 작성 용이                 | 일회성, 자원 닫기 필요 가능, `size` 등 탐색연산 부재      | 특수      |
| `Iterable`   | 가벼움, for-each 친화, `stream()`로 쉽게 변환 가능(어댑터)         | `size/contains` 없음, 스트림 파이프라인 직접 제공 안 함 | 경량      |

### 언제 `Stream`을 반환해도 괜찮을까?
- **IO/DB 커서, 매우 큰 시퀀스, 무한/지연 스퀀스** 등: 컬렉션으로 담기 부적절할 때
- 단, **일회성, 자원관리**를 **명확히 문서화**해야한다

### `Iterable`을 반환하는건 어떨까?
- for-each 친화적이고 가벼움
- `streamOf(iterable)` 어댑터로 스트림도 쉽게 뽑아 쓸 수 있음.
- 크기, 포함 여부가 필요하면 `Collection`이 낫다

### 둘 다 주고싶을 땐 어떻게 할까
- **반환은** `Collection`(가장 범용성 큼)
- 별도 헬퍼로 `collection.stream()`이나 어댑터 메서드를 제공

### 불변 컬렉션을 권장하는 이유는 뭘까
- 외부에서 수정 불가 -> **부작용, 방어적 복사 비용 감소** -> API 신뢰성 상승

### 크키가 큰 결과는 어떻게 처리할까
- **페이징**(Page, Slice) 또는 **스트림 반환**을 고려
- 클라이언트가 전부 메모리에 올리도록 강제하지 말자.

## 요약
> **반환 타입으로는 우선** `Collection`**을 선택하자**  
> 컬렉션으로 만들기 힘들 때에만 `Stream`/`Iterable`을 고려하고,  
> 필요 시 `Iterable <-> Stream` 어댑터를 제공해 사용성을 높이자.  
> (자원 연동 스트림은 **일회성/close 필요**를 명확히 문서화 하자)