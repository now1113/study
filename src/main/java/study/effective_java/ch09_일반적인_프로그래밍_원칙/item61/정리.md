:trophy: 이펙티브 자바 스터디 - 아이템 61

:book: 아이템 61: 박싱된 기본 타입보다는 기본 타입을 사용하라

## 왜 기본 타입(primitive)을 우선해야 할까
- **NPE 안전**: 기본타입은 `null`이 불가 -> 언박싱 NPE 없음.
- **성능**: 박싱/언박싱은 힙 할당, GC 비용 유발.
- **비교 일관성**: 기본 타입 `==`는 값 비교. 박싱 타입 `==`는 **참조 비교**(버그 위험)

### 박싱 타입을 쓸 예외 상황
- **제네릭/컬렉션 경계**(`List<Integer>`)
- **진짜 부재를 표현**해야 할 때(`null` 필요)
- 프레임워크/라이브러리 **API 제약**으로 객체 타입이 요구될 때

### 함정
```java
Integer n = null; int x = n;            // 언박싱 NPE
Integer a = 128; int b = 128; a == b;   // false (참조비교)
Long sum = 0L; for (long i=0;i<N;i++) sum += i; // 매 반복 박싱 발생
```

### 책에서 권하는 원칙
- **기본 타입 우선**, 박싱은 꼭 필요할 때만.
- **합계, 카운터, 루프 변수**는 기본 타입.
- 박싱 비교는 `==`금지 -> `equals`/`compareTo`/`Objects.equals`
- **스트림/옵셔널 특화형**(`IntStream`, `OptionalInt`) 사용으로 박싱 제거
- `int`와 `Integer` **오버로드 혼용 금지**(모호성/예상 밖 바인딩)


## 아래 예제가 느린 이유
```java
Long sum = 0L;
for (long i = 0; i <= Integer.MAX_VALUE; i++) {
    sum += i;
}
```
### 매 반복마다 오토박싱/언박싱 발생.
```java
// sum += i;
sum = Long.valueOf(sum.longValue() + i);
```
- `sum.longValue()`: **언박싱** (객체 -> primitive)
- `+ i`: primitive 연산
- `Long.valueOf(...)`: **박싱** (primitive -> 객체)

### 할당 폭증(힙 객체 생성) + GC 난사
- `sum`값이 `127`을 넘는 순간부터 `Long.valueOf`는 **새 Long 객체를 매번 생성**한다(캐시는 -128 ~ 127 범위)
- 반복 횟수는 `Integer.MAX_VALUE + 1` **약 21억 번.**
- Long 객체 1개가 대략 **~24바이트**(헤더 포함, 64비트 + compressed OOP 가정)라고 치면, 이론상 생성/수거되는 메모리가 **수십 GB** 규모
  - **할당 속도 한계 + 카드마킹/쓰기배리어 + Stop-the-world GC**로 성능이 붕괴

### 레지스터/캐시 지역성 상실
- primitive `long` 누산은 **레지스터 안**에서 돌아가 CPU 친화적이다.
- 반면 박싱은 **힙 객체 참조 갱신**이라 포인터 추적/쓰기배리어/캐시 미스가 잦아진다.

### JIT 최적화 제약
- 이 패턴은 루프 바깥으로 객체 생성을 빼거나 **escape analysis**로 제거하기 어렵다.
- 누산 값이 **매번 새 객체**로 치환되고 메서드 밖으로 탈출하므로 **스칼라 치환**이 잘 되지 않는다.