:trophy: 이펙티브 자바 스터디 - 아이템 64

:book: 아이템 64: 객체는 인터페이스를 사용해 참조하라

## 왜 인터페이스를 참조해야 할까
- **유연성**: 구현체 교체가 쉽다. `ArrayList -> LinkedList`, `HashMap -> LinkedHashMap` 등.
- **결합도 감소**: 구체 클래스에 묶이지 않으니 **테스트 더블** 투입이 쉽다.
- **취소 필요 계약**만 노출: 필요한 연산만 가진 **가장 일반적인 인터페이스**로 타입을 좁히면, 사용처가 구현 세부에 의존하지 않는다.

> **사용은 인터페이스에, 생성은 구현체로**  
> `List<String> list = new ArrayList<>();`


## 예시

### 컬렉션을 구체 클래스로 노출 -> 인터페이스로 축소

```java
public class UserDirectory {
    private final ArrayList<String> users = new ArrayList<>();
    
    public ArrayList<String> getUsers() {
        return users;
    }

    public void addAll(ArrayList<String> toAdd) {
        users.addAll(toAdd);
    }
}
```
```java
public class UserDirectory {
    private final ArrayList<String> users = new ArrayList<>();

    public List<String> users() {
        return Collections.unmodifiableList(users);
    }

    public void addAll(Collection<? extends String> toAdd) {
        users.addAll(toAdd);
    }
}
```

### 문자열 처리: String 고정 -> CharSequence

```java
public class StringExample {

    public static void main(String[] args) {
        System.out.println(isPalindrome("level"));
        System.out.println(isPalindrome(new StringBuilder("abcd")));
    }

    // String으로 고정되면 StringBuilder, StringBuffer를 못받음
    public static boolean isPalindrome(String s) {
        int i = 0;
        int j = s.length() - 1;

        while (i < j) {
            if (s.charAt(i) != s.charAt(j--)) {
                return false;
            }
        }
        return true;
    }

    // CharSequence로 일반화
    public static boolean isPalindrome(CharSequence s) {
        int i = 0;
        int j = s.length() - 1;

        while (i < j) {
            if (s.charAt(i) != s.charAt(j--)) {
                return false;
            }
        }
        return true;
    }
}
```

## 입력/반환 타입 설계
- **매개변수 타입**: 필요한 연산의 **최소 인터페이스**로 받자.
  - 읽기만 하면 `Iterable`/`Collection`, 순서 필요하면 `List`, 큐 동작이면 `Queue`/`Deque`
- **반환 타입**: 일반적으로 인터페이스로 반환.
  - 다만 **구체 클래스 고유 API**를 꼭 써야한다면 구체 클래스를 반환할 수도 있다.(`BitSet` 등)
  - 읽기 전용으로 주고싶으면 `List.copyOf(...)`, `Set.copyOf(...)`, `Collections.unmodifiableXxx(...)` 등을 사용하자.
- **필드/지역변수**: 인터페이스로 선언하고, **생성은 구현체로**
- **예상치 못한 의존 방지**: 메서드 시그니처에 `ArrayList`, `HashMap` 같은 **구현 클래스 노출을 하지말자.**