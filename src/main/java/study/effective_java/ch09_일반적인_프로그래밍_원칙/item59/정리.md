:trophy: 이펙티브 자바 스터디 - 아이템 59

:book: 아이템 59: 라이브러리를 익히고 사용하라

## 핵심
- **바퀴를 다시 만들지 마라.** 이미 잘 설계, 검증된 **표준 라이브러리를 우선** 사용하자.
- 얻는 이점: **정확성**(다수의 사용자, 테스트로 검증), **성능 최적화, 보안/안정성, 가독성, 일관성, 유지보수 용이**
- JDK는 **방대한 범용 기능**을 제공한다. 직접 구현하려 들지 말고 **먼저 찾자**.
- 라이브러리 사용은 **API 의도**를 드러내고, 팀 동료가 코드를 더 쉽게 이해하도록 돕는다.
- 직접 구현이 쉬워 보여도 **경계 조건, 성능, 병렬성, 국제화** 등에서 허점이 생기기 쉽다.


## 예시

```java
// 직접 문자열 합치기
String s = "";
for (String part : parts) {
    s += "," + part;
}

// 표준 라이브러리
String s1 = String.join(",", parts);
```
```java
// 날짜 파싱 직접 구현
String y = "";
String m = "";
String day = "";
String input = "";
LocalDate date = LocalDate.of(
        Integer.parseInt(y), Integer.parseInt(m), Integer.parseInt(day)
);

// java.time + formatter
DateTimeFormatter F = DateTimeFormatter.ofPattern("yyyy-MM-dd");
LocalDate parse = LocalDate.parse(input, F);
```

## 예외 사항
- **아주 사소한 기능**이거나, 의존 추가 비용이 더 클 때는 직접 작성도 가능.
- 단, 표준/검증 라이브러리로 **대체 가능성**을 먼저 검토하고, 직접 구현 시 **테스트/문서화**로 리스크를 줄이자.

## 표준 라이브러리 정리
- 문자열 결합/포맷 -> `String.join`, `String.format`, `Formatter`
- 인덱스 순회 목적 -> for-each
- 날짜/시간 파싱/연산 -> `java.time` + `DateTimeFormatter`
- 파일 I/O 유틸 자체구현 -> `Files` / `Path`
- 스레드/타이머 직접 관리 -> `ExecutorService` / `ScheduledExecutorService` / `CompletableFuture`
- 동시성 컬렉션 미사용 -> `ConcurrentHashMap` / `BlockingQueue`
- 경로 문자열 이어 붙이기 -> `Path.of`
- 난수/ID 생성에 `Random` 사용 -> `SecureRandom` / `UUID`