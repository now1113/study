:trophy: 이펙티브 자바 스터디 - 아이템 67

:book: 아이템 67: 최적화는 신중히 하라

## 핵심
- **성급한 최적화는 해악**이다. 먼저 **명확하고 올바른 코드**를 작성하고, **실측(프로파일/벤치마크)** 으로 병목을 찾아 **정말 필요한 부분만 손대자.**

## 왜 신중해야할까
- **가독성, 유지보수성 저하**: 미세 최적화는 코드 복잡도를 높여 버그와 유지 비용을 키운다.
- **오판 가능성**: 추정으로 손대면 **병목이 아닌 곳**을 최적화하기 쉽다.
- **환경 의존성**: JVM/JIT/GC/하드웨어에 따라 결과가 달라져 **일반화가 어렵다.**
- **대부분의 성능은 설계/알고리즘이 좌우**: 미세한 트릭보다 **적절한 자료구조, 알고리즘 선택**이 압도적이다.

## 책에나온 원칙

### 빠른 프로그램보자 좋은 프로그램을 먼저
- 성능 때문에 견고한 구조를 희생하지 말자.
- 잘 설계된 구조는 **나중 최적화의 경로**를 열어준다(교체, 확장 용이)

### 성능을 제한하는 설계를 피하자
- 컴포넌트/외부 시스템과의 **소통 방식**(원격 호출, 파일/네트워크 I/O)이 가장 비싼 구간이 되기 쉽다.
- 이런 설계 요소들은 **완성 후에는 변경하기 어렵거나 불가능할 수 있다**

### API를 설계할 때 성능에 주는 영향을 고려하자
- **불필요한 방어적 복사 유발 금지**: 가변 배열/컬렉션을 그대로 노출하면 호출마다 방어적 복사가 필요해진다. 읽기 전용 뷰나 불변 반환, 스트리밍 방식 등으로 복사 빈도를 줄이자.
- **상속 남용 대신 컴포지션 우선**: 컴포지션으로 해결 가능한데도 상속을 택하면 상위 클래스의 구현, 성능제약을 하위 클래스가 영구히 물려받는다. 컴포지션을 통해 내부 구현, 교체, 최적화 여지를 남기자.
- **구현 타입 노출 금지, 인터페이스 사용**: 공개 API에서 `ArrayList`/`HashMap` 같은 구현 타입을 드러내면 특정 구현에 종속된다. `List`, `Map` 등 인터페이스로 설계해, 이후 더 바른 구현으로 교체가 가능하도록 하자.


### 성능을 위해 API를 왜곡하지 말자
- 성능만 보고 특이한 형태의 API를 제공하면 **영구적 부채**가 된다.

### 각 최적화 시도 전후로 반드시 측정하자
- 사람의 직감은 잘 빗나간다. **프로파일러**로 병목을 찾고, 동일 조건에서 **전,후 비교**하자.
- **대포 워크로드**로 측정하고, **JIT, 워밍업** 동일 환경을 맞추자.
