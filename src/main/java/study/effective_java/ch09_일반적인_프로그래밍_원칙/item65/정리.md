:trophy: 이펙티브 자바 스터디 - 아이템 65

:book: 아이템 65: 리플렉션보다는 인터페이스를 사용하라

## 정리
- 리플렉션은 **동적 로딩/메타데이터 처리**에는 유용하지만, **타입 안정성, 가독성, 성능 손해**가 크다.
  - **인스턴스 생성에만 최소한으로 쓰고, 사용은 인터페이스 (또는 상위 클래스)로** 하자.

## 리플렉션
- `java.lang.reflect`를 통해 **런타임에 임의 클래스에 접근**(클래스 이름 문자열)
- `Class`에서 `Constructor/Method/Field`를 얻어 **생성, 호출, 접근** 가능.
- `Method.invoke`로 **어떤 객체의 어떤 메서드든 호출**할 수 있다.

### 리플렉션의 단점
- **컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.** -> 오류가 런타임에 터짐
- **코드가 지저분하고 장황해진다.**(예외/리플렉션 호출 난무)
- **성능 저하.**(리플렉션 호출/접근 검사/박싱 등 오버헤드)

### 리플렉션은 어떻게 써야할까?
- **리플렉션은 아주 제한된 형태로만 사용해야 단점을 피하고 이점만 취할 수 있다.**
- 컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있을 것이다.
- 이 경우라면 **리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.**

## 헷갈렸던 부분
> “컴파일타임에 이용할 수 없는 클래스를 써야만 해도, 적절한 인터페이스/상위 타입은 컴파일타임에 준비할 수 있다.  
> 이때 리플렉션은 ‘생성’에만 쓰고, 생성된 객체는 인터페이스/상위 타입으로 참조하라.

- 의미: 플러그인처럼 **구현체 이름은 런타임에 알지만**, 사용 코드는 **컴파일 시점에 계약(인터페이스)** 를 알고 있다.
  - **동적 로딩**(클래스명 -> 객체 생성)은 리플렉션으로 한 번만.
  - 이후 호출은 **인터페이스 타입 변수**로 안전하게

## 예시

### 나쁜 예: 생성, 호출 전부 리플렉션
```java
public interface Plugin {
  String run(String in);
}

public class UpperPlugin implements Plugin {
  @Override
  public String run(String in) {
    return in.toUpperCase();
  }
}

public class BadAllReflection {
    public static void main(String[] args) throws Exception {
        // 외부 설정에서 온다고 가정
        String fqcn = UpperPlugin.class.getName();
        Class<?> cl = Class.forName(fqcn);
        Object obj = cl.getDeclaredConstructor().newInstance();

        // 매 호출마다 리플렉션(느림) + 문자열 의존(타입 안전성 없음)
        Method run = cl.getMethod("run", String.class);
        String out = (String) run.invoke(obj, "hello");
        System.out.println(out);
    }
}
```

### 좋은 예: 생성만 리플렉션, 사용은 인터페이스
```java
public interface GPlugin {
    String run(String in);
}

public class GUpperPlugin implements GPlugin{
  @Override
  public String run(String in) {
    return in.toUpperCase();
  }
}

final class Plugins {
  static GPlugin create(String fqcn) {
    try {
      // asSubClass로 GPlugin의 하위 타입만 허용
      Class<? extends GPlugin> cl = Class.forName(fqcn).asSubclass(GPlugin.class);
      return cl.getDeclaredConstructor().newInstance();
    } catch (ReflectiveOperationException e) {
      throw new IllegalArgumentException("플러그인 로딩 실패: " + fqcn, e);
    }
  }
}

public class GoodCreateOnly {
  public static void main(String[] args) {
    String fqcn = GUpperPlugin.class.getName();
    // 리플렉션은 여기서 한번
    GPlugin plugin = Plugins.create(fqcn);
    // 이후에는 인터페이스로 안전하게 처리
    System.out.println(plugin.run("hello"));
  }
}
```

## 리플렉션은 어디에서 쓰일까
- **JPA/Hibernate**: 엔티티 무인자 생성자 호출, 프록시 생성, private 필드 접근
- **Spring DI/AOP**: 생성자/필드/세터 주입, 프록시 기반 부가기능.
- **Jackson/Gson**: 무인자 생성 + 필드/게터 스캔으로 직렬화/역직렬화