:trophy: 이펙티브 자바 스터디 - 아이템 62

:book: 아이템 62: 다른 타입이 적절하다면 문자열 사용을 피하라

## 문자열을 잘못쓰는 사례들
- **입력 값을 무조건 문자열로 받는 경우**  
  - 숫자는 수자, 예/아니오는 `boolean`/`enum` 등 **알맞은 타입으로 즉시 변환**하는 편이 안전하다.
- **열거 타입을 문자열로 대신**
  - `"ACTIVE"`, `"INACTIVE"`처럼 상태를 문자열로 비교하면 오타, 대소문자, 정규화 이슈를 컴파일러가 잡지 못한다.
- **혼합 타입을 문자열로 대신**
  - 구분자 충돌이 일어날 수 있다.(예상치 못한 결과 초래) 
  - 문자열을 다시 파싱해야 하고(느리고 취약), 구조가 없으니 `equals`/`hashCode`/`compareTo`같은 의미 있는 연산도 제대로 제공하기 어렵다.
- **권한을 문자열로 표현하는 한계**
  - 형태만 맞으면 통과되기 쉬워 위조에 취약하다.
  - 생성 시점에 검증, 보호를 적용하기 어렵다.

### 혼합 타입을 남용하는 예
```java
String compoundKey = className + "#" + i.next();
```
- `#`이 `className`이나 `i.next()`에 포함되면 **구분자 충돌**이 발생한다.
- 나중에 다시 분해하려면 **재파싱 비용과 오류 가능성**이 커진다.
- 구조가 없으므로 의미 있는 **동치성/정렬 기준**을 정의하기 어렵다.
  - 전용 값 타입(레코드/클래스)로 **구조와 불변식**을 드러내는 편이 옳다.

### 문자열로 권한을 잘못 구분하는 예시
```java
public class ThreadLocal {
  private ThreadLocal() {} // 객체 생성 불가

  // 현 스레드의 값을 키로 구분해 저장한다.
  public static void set(String key, Object value);

  // 현 스레드의 값을 반환한다.
  public static Object get(String key);
}
```
- 문자열 키가 **전역 이름공간**을 공유하므로 충돌, 오염이 쉽다.
- 악의적/부주의한 클라이언트가 같은 키를 쓰면 **서로의 값을 덮어쓰거나 읽는 문제**가 생긴다.
- 키를 외부에서 **위조**하기 쉬워 보안에 취약하다.

### `Key` 클래스로 권한 구분하기
```java
public class ThreadLocal {
  private ThreadLocal() {} // 객체 생성 불가
  
  public static class Key { // (권한)
    Key() { }
  }

  // 위조 불가능한 고유 키를 생성한다.
  public static Key getKey() {
    return new Key();
  }
  
  public static void set(Key key, Object value);
  public static Object get(Key key);
}
```
- 문자열 타입의 `Key`를 이용해 권한을 구분했는데, 이제는 `Key` 클래스를 이용한다.
- 문자열 기반에서 다른 스레드의 `ThreadLocal` 변수에 접근할 수 있었던 보안 취약점이 사라졌다.
- 이제 `set()`과 `get()`은 정적일 필요가 없기 때문에, `Key`의 인스턴스 메서드로 바꾸자
- `Key`는 스레드 지역변수를 구분하기 위한 키보다는 스레드 지역변수 자체가 된다.
  - `Key`의 이름을 `ThreadLocal`로 바꾸어 버리자.

```java
public final class ThreadLocal {
  public ThreadLocal();
  public void set(Object value);
  public Object get();
}
```
- 형변환 문제가 남았지만 `ThreadLocal`을 `매개변수화 타입`으로 선언하면 문제가 해결된다.

```java
public final class ThreadLocal<T> {
  public ThreadLocal();
  public void set(Object value);
  public T get();
}
```

## ThreadLocal: `Key` -> 인스턴스 자체가 키로 이어지는 동작 정리
각 `Thread`는 자기만의 `ThreadLocalMap`을 가진다(`threadLocals` 필드.)  
`ThreadLocal#get/set`을 호출하면 **현재 스레드의 맵**을 가져와 **그** `ThreadLocal`**인스턴스 자신을 키**로 사용해 값에 접근한다.

이때 맵의 **키는 약한 참조(WeakReference)** 로 보관되고, 값은 강한참조라 누수 가능성이 있어 **스레드 풀 사용 시 `remove()` 습관화**가 권장된다.  
`ThreadLocal`**은 보통** `private static` **필드로 선언**해서, 동일한 인스턴스를 전 스레드가 **자기 맵안에서 각자 다른값**으로 보유하게 만든다.


### 코드 
```java
public class Thread implements Runnable {
  ...
  ThreadLocal.ThreadLocalMap threadLocals = null;
}
```
- `ThreadLocal`이 이 맵을 관리한다.
```java
public class ThreadLocal<T> {
  ...
  public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
      ThreadLocalMap.Entry e = map.getEntry(this);
      if (e != null) {
        @SuppressWarnings("unchecked")
        T result = (T)e.value;
        return result;
      }
    }
    return setInitialValue();
  }

  public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
      map.set(this, value);
    } else {
      createMap(t, value);
    }
  }
  
  protected T initialValue() {
    return null;
  }

  ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
  }

  void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
  }

  static class ThreadLocalMap {
    ...
    static class Entry extends WeakReference<ThreadLocal<?>> {
      /** The value associated with this ThreadLocal. */
      Object value;

      Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
      }
    }
}
```
- `set`이 처음 호출되면 현재 스레드의 맵이 없을 수 있으므로 **지연 생성**한다.
- 여기서 **키는** `this`(**해당 ThreadLocal 인스턴스**)다. 이후 `get()`/`set()`은 현재 스레드의 맵에서 `this`**를 키로 조회/저장**한다.

### 왜 인스턴스 자체가 키일까
`ThreadLocalMap`의 엔트리는 **키를** `WeakReference<ThreadLocal<?>>`로 들고 있어, 외부에서  
`ThreadLocal` 인스턴스를 더 이상 참조하지 않으면 키가 수거될 수 있다.

이는 **문자열 키 전역 네임스페이스 충돌/위조**문제를 제거하면서, GC 관점에서도 관리가 가능하도록 한 설계다.

### 사용 패턴(`private static`)
공식 문서는 `ThreadLocal`을 **클래스의** `private static` **필드**로 두라고 권한다.  
하나의 인스턴스(=키)를 전역에서 공유하되, **실제 값은 각 스레드의 맵에서 분리 저장**되기 때문이다.