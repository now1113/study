:trophy: 이펙티브 자바 스터디 - 아이템 57

:book: 아이템 57: 지역변수의 범위를 최소화하라

## 핵심
- **가독성/이해도**: 변수가 보이는 범위가 좁을수록 코드 읽기가 쉽다.
- **버그 감소**: 실수로 재사용/덮어쓰기/섀도잉(동명이인 변수)될 위험이 줄어든다.
- **테스트/리팩토링 용이**: 역할이 분리되어 변경 파급이 작다.


## 규칙 (How-to)

### 사용 직전에 선언 + 즉시 초기화

```java
// 나쁨: 위에 모아서 선언하면 실제 의미가 흐려짐
int count;
List<Integer> exList = List.of(1, 2, 3, 4);
count = exList.size();

// 좋음
int count2 = exList.size();
```
### 가장 좁은 블록에 묶기 (if, for, try)

```java
// i가 루프 밖에서 살아남음
int i = 0;
int n = arr.length;
while (i < n) {
    int i1 = arr[i++];
}

// for가 범위를 루프 내부로 제한
for (int i = 0; i < arr.length; i++) {
    int i1 = arr[i++];
}
```

### for-each / 스트림으로 루프 변수 범위를 더 줄이기

```java
for (Element e : elements) {
    handle(e);
}
// 또는
elements.stream().forEach(this::handle);
```

### 반복문 사이 변수 재사용 금지

```java
// i를 두 루프에서 재사용 → 가독성/실수 위험
for (Iterator<A> i = a.iterator(); i.hasNext(); ) { ... }
for (Iterator<B> i = b.iterator(); i.hasNext(); ) { ... }

// 각각의 루프 안에서 새로 선언
for (Iterator<A> it = a.iterator(); it.hasNext(); ) { ... }
for (Iterator<B> it = b.iterator(); it.hasNext(); ) { ... }
```

### try-with-resources로 자원의 범위를 강제 축소

```java
try (var in = Files.newInputStream(p);
     var out = Files.newOutputStream(q)) {
    in.transferTo(out);
} // in/out은 여기서 생을 마침
```

### 그 외
- **메서드를 작게 쪼개서 지역변수 수/범위 줄이기**
  - 한 메서드에서 지역 변수가 많고 생존 구간이 길다면, **추출(Extract Method)하자.**
- `final`/**effectively final**로 의도를 고정
  - 재할당이 필요 없다면 `final` 또는 사실상 불변(다시 대입 없음)으로 두면 람다/스트림에서 안전하고 실수도 줄어든다.


## 자주 나오는 안티패턴
- **나중에 쓰겠지 라며 메서드 상단에 몰아 선언** -> 실제로 안 쓰거나 오래 살아남아 혼란.
- **플래그 변수 하나로 분기 곳곳 제어** -> 플래그 범위가 필요 이상 커짐 -> **가드 절/조기 return**으로 축소.
- **외부 변수를 람다에서 캡쳐해 변경** -> 가독성 낮아지고 동시성 위험 증가 -> **수집자/리듀서**로 대체.

```java
// 외부 상태 변경
int[] sum = {0};
a.forEach(i -> sum[0] += i);

// 범위가 루프 안으로 갇힌 리듀스
int sum2 = a.stream().mapToInt(Integer::intValue).sum();
```

## 정리
- 선언은 **첫 사용 직전**인가?
- **블록**(if/for/try) 안에 가둘 수 없는가?
- **변수 재사용**하고 있지 않은가?
- **가드 절/조기 반환**으로 생존 시간을 줄일 수 없는가?
- 람다/스트림에서 **외부 가변 상태**를 캡쳐하지 않았는가?

> **변수는 꼭 필요한 곳에서만, 딱 필요한 동안만 보이게하자.**