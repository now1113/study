:trophy: 이펙티브 자바 스터디 - 아이템 76

:book: 아이템 76: 가능한 한 실패 원자적으로 만들라

## 실패 원자성(Failure Atomicity)
어떤 **메서드 호출이 예외로 실패했을 때**, 그 객체의 상태가
- **호출 이전 상태로 그대로 유지되거나**
- **명세에 정의된 안전한 상태**로만 바뀌고

**중간에 반쯤 바뀐 상태(부분 갱신)** 가 남지 않도록 만드는 성질이다.

> 여기서 원자적은 동시성의 atomic(락/원자 연산)과 다르고, **예외 발생 시 객체 상태가 깨지지 않는다는 의미**에 가깝다.


## 왜 중요할까

실패 원자성이 없으면 예외가 터진 뒤에 객체가 **불변식(invariant)** 을 깨거나,  
다음 호출에서 더 큰 장애로 번진다.

- 데이터 구조가 꼬여서 이후 작업이 NPE/무한 루프/데이터 손상
- "실패했으니 아무 일도 없었겠지" 라는 호출자 가정이 깨진다. 
- 장애 재현이 어려워지고, 롤백 로직이 호출자/상위 계층으로 전파


## 실패 원자성을 달성하는 방법

### 불변 객체로 만들기
불변 객체는 상태 변경 자체가 없어서, 실패 원자성을 사실상 공짜로 얻을 수 있다.
- 변경이 필요하면 **새 인스턴스**를 만들어 반환
- 예외가 나면 기존 인스턴스는 그대로

### 검증을 먼저하고, 변경은 나중에
상태 변경 전에 **모든 입력 검증/실패 가능 작업**을 먼저 수행한다.
- 실패 가능한 작업(파싱, 범위 체크, 외부 호출, 인덱스 계산 등)을 먼저
- 그 다음에 "실패 가능성이 거의 없는" 상태 변경을 수행


### Copy-and-swap
현재 상태를 바꾸지 않고 **복사본에서 모든 작업을 끝낸 다음,** 마지막에 한번에 교체한다.
- 컬렉션 정렬/필터/재구성
- 내부 배열/리스트/맵을 통째로 바꾸는 형태에 잘 맞음

### 실패 가능한 연산의 순서를 조정 (Order to minimize damage)
여러 단계 변경이 필요할 때
- "가장 실패 가능성이 큰 단계"를 먼저 수행
- 뒤로 갈수록 실패 가능성이 낮아지게 정렬


### 복구 코드(롤백)를 명시적으로 넣기
어쩔 수 없이 중간 변경이 필요한 경우
- catch에서 되돌리거나
- 변경 전 스냅샷을 저장했다가 복원

> 주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰이나,  
> 자주 사용하는 방법은 아님


## 결론
- 실패 원자적으로 만들 수 있더라도 항상 그래 해야 하는 것은 아니다
  - 실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 연산도 있기 때문
- 그래도 문제가 무엇인지 알고 나면 실패 원자성을 공짜로 얻을 수 있는 경우가 더 많다.
