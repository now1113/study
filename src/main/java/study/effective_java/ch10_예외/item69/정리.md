:trophy: 이펙티브 자바 스터디 - 아이템 69

:book: 아이템 69: 예외는 진짜 예외 상황에만 사용하라

## 잘못 사용한 예시

```java
Step[] range = new Step[10];

try {
  int i = 0;
  while (true) {
    range[i++].climb();
  }
} catch (ArrayIndexOutOfBoundsException e) {
}
```
- 위 코드만 봐서는 **무슨 일을 하는지 직관적으로 알 수 없다.**
- 배열 순회를 **무한 루프 + 경계 예외**로 끝내는 끔찍한 방식이다.
- 같은 일을 **표준 관용구**로 쓰면 바로 이해된다.

```java
for (Step s : range)
    s.climb();
```

## 위 코드는 왜 잘못되었을까
- **예외는 예외 상황에 쓰라고 설계**되었다. 정상적인 제어 흐름(순회 종료)을 예외로 처리하면 **API 계약을 거꾸로** 쓰는 꼴이다.
- **가독성/유지보수성 저하**: 의도가 `try-catch` 안에 숨어 코드 이해가 어렵다.
- **성능 손해**: 예외 생성과 스택 트레이스 수집 비용이 크다. 정상 경로에서 반복적으로 던지면 **현저히 느려진다,**
- **버그 은닉 위험**: 반복문 내부 버그가 예외 흐름에 섞여 **드러나지 않고 묻히기 쉬워** 디버깅이 어려워진다.

## 표준 관용구
- **배열/컬렉션**: 인덱스 조건 또는 **향상된 for**로 순회
  - `for(int i = 0; i < range.length; i++) ...`/`for (Step s : range)`
- **Iterator**: `hasNext()`로 **상태 검사** -> `next()` 수행
  - 반복 종료를 예외로 감지하지 말자
- **탐색/부재**: 예외 대신 **명확한 반환 규약** 사용
  - ex) `Map`은 `containsKey`/`getOrDefault`, 조회는 **빈 컬렉션** 반환, 단일 값은 필요시 `Optional` 등

## forEach는 내부적으로 어떻게 동작할까
- `Iterable.forEach`의 기본 구현은 **해당 컬렉션을 순회**하며 각 원소에 `accept`를 호출한다.
- 실제로는 **향상된 for**(= 내부적으로 `Iterator`의 `hasNext()/next()` 활용)로 전개된다.
- **정상적인 상태 검사**(hasNext)로 진행, **예외로 종료**하지 않는다.

## hasNext를 제공하지 않았다면
- 클라이언트는 **반복 종료를 감지할 방법이 없고**, 결과적으로 `next()`가 던지는 예외에 의존하게 된다.
- 책의 메세지처럼 **잘 설계된 API**라면, **정상 제어 흐름에서 예외 사용을 강요하지 않도록** `hasNext`같은 **상태 검사 메서드**를 만드시 제공해야 한다.

## 핵심
- **예외는 오직 예외 상황에서만** 사용해야 한다.
- **정상 제어 흐름은 검사(상태 확인)** -> **수행**과 **명확한 반환 규약**으로 표현하자
- 클라이언트에게 **예외 사용을 강요하는 API**를 만들지 말자.

