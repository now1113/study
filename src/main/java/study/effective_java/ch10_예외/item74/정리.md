:trophy: 이펙티브 자바 스터디 - 아이템 74

:book: 아이템 74: 메서드가 던지는 모든 예외를 문서화하라

## 핵심
- **공개된 메서드는 자신이 던지는 예외를 반드시 문서화해야 한다.**
- 단, **검사 예외와 비검사 예외를 다루는 방식이 다르다.**
  - **검사 예외(checked)** -> `throws`절 + Javadoc `@throws`에 명시
  - **비검사 예외(unchecked, RuntimeException 계열)** -> `throws`**절에는 쓰지 말고,** 필요하면 Javadoc `@throws`에만 상황을 문서화
- 예외 문서는 메서드의 **계약(contract)의 일부**다.

## 검사 예외(checked exception) 문서화

### 처리 방법
- 검사 예외는 **컴파일 타임에 강제되는 예외**이기 때문에
- **메서드 선언부의 `throws`절에 명시**
- **Javadoc의 `@throws` 태그로 언제 던지는지를 설명**

```java
    /**
     * 지정한 경로의 설정 파일을 로드한다.
     *
     * @Param path 설정 파일 경로 (null 불가)
     * @return 설정 정보
     * @throws NullPointerException if path is null
     * @throws IOException          if an I/O error occurs while reading
     */
    public Properties loadConfig(Path path) throws IOException {
        return null;
    }
```
- 호출자는
  - 컴파일 시점에 **이 예외를 처리하거나 전파해야 함**을 알 수 있고
  - Javadoc으로 **어떤 조건에서 발생하는지**를 구체적으로 알 수 있다.


## 비검사 예외(unchecked exception) 문서화
**비검사 예외는 메서드 선언의 `throws`절에 기입하지 말자.**  
대신, **API 계약에 중요하다면 Javadoc `@throws`로만 문서화 하자.**

### 왜 `throws`절에 쓰면 안될까
- 비검사 예외는 **컴파일러가 강제하지 않는다.**
  - `throws`에 써도, 안 써도 **catch/throws가 강제되지 않는다.**
- 그럼에도 `throws`에 비검사 예외를 써버리면
  - **시그니처가 지저분해진다.**
    - 반드시 처리해야 하는 예외와 참고용 예외가 뒤섞인다.
  - **API 사용자에게 잘못된 인상을 준다.**
    - 마치 이 예외를 꼭 처리해야 할 것처럼 보일 수 있다.
  - **구현 변경 시 부담이 커진다.**
    - 런타임 예외는 구현 세부사항에 가까운데, `throws`에 적어버리면 API의 일부처럼 굳어진다.
    - 나중에 해당 예외를 안 던지게 바꾸거나, 다른 런타임으로 바꾸면 문서/코드 일관성을 맞추기 힘들어진다.

그렇기 때문에
- **비검사 예외는 메서드 선언(`throws`)에는 넣지 말고,**  
- **Javadoc의 `@throws`로만 "어떤 상황에서 발생하는지"를 문서화하라고** 권한다.

### 어떻게 문서화하는게 좋을까
- 예외가 **API 계약상 의미 있는 실패 모양**이라면, `@throws`로 언제 던지는지를 적어주자.

```java
/**
 * 스택의 맨 위 원소를 제거하고 반환한다.
 * 
 * @return 제거된 원소
 * @throws java.util.NoSuchElementException if this stack is empty
 */
public E pop() {
    return null;
}
```
- 여기서 `NoSuchElementException`은 **RuntimeException 계열(비검사)** 이지만,
- "빈 스택에서 호출하면 이런 식으로 실패한다"는 것은 이 메서드를 사용하는 사람에게 **계약의 핵심**이기 때문에 `@throws`에 문서화 하는것이다.

## 내부 구현 예외 vs 외부에 문서화할 예외
- 내부 구현에서 여러 비검사 예외가 발생할 수 있어도,
  - `NullPointerException`, `IndexOutOfBoundsException`, `IllegalStateException` ...
- 이 중에서 **호출자가 알아야 하는 것만 추려서** 문서화 하자.

```java
/**
 * 지정한 index 위치의 요소를 반환한다.
 * 
 * @param index 0 이상, size 미만
 * @return index 위치의 요소
 * @throws IndexOutOfBoundsException if index is out of range (index < 0 || index >= size)
 */
public E get(int index) {
    // 내부에서 NPE 등이 발생할 수 있지만, 그건 구현 세부사항이고
    // index 범위를 벗어나면 IndexOutOfBoundsException 이라는 계약이 핵심이다.
    return null;
}
```
- 여기서 `IndexOutOfBoundsException`은 비검사 예외지만
  - 컬렉션 API 전반에서 "범위 오류"를 의미하는 표준 예외라,
  - **계약의 일부로 문서화하는 것이 자연스럽다.**
- 반면에, 내부적인 NPE/IllegalStateException 같은건
  - 계약으로 삼을 필요가 없다면 굳이 문서화 하지 않아도 된다.

## 정리
- **공개 메서드는 자신이 던지는 예외를 문서화해야 한다.**
- 다만 검사/비검사 예외를 다루는 방식이 다르다.
- **검사 예외(checked)**
  - `throws`절에 선언
  - Javadoc `@throws`로 "어떤 상황에서 발생하는지" 설명
- **비검사 예외(unchecked: RuntimeException, Error 계열)**
  - **메서드 선언부의 `throws`절에는 쓰지 않는다.**
  - 메서드 계약상 중요한 예외라면 Javadoc `@throws`로만 "언제 발생하는지"를 문서화 하자.

