:trophy: 이펙티브 자바 스터디 - 아이템 70

:book: 아이템 70: 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

## 용어와 구분

### 검사 예외(Checked Exception)
- `Exception`의 하위이면서 `RuntimeException`의 하위가 아닌 예외
- **호출자가 복구(재시도, 대안 경로 선택, 사용자 입력 재요청 등)를 합리적으로 수행할 수 있을 때** 사용한다.
- API 사용자가 **반드시 처리하도록 강제**(컴파일 타임에 catch/throws 필요)

### 런타임 예외(비검사 예외, Unchecked Exception)
- `RuntimeException`의 하위, **프로그래밍 오류/전제조건 위반(계약 위반, 불변식 붕괴, 잘못된 사용)을 나타낸다.**
- **정상적인 사용이라면 발생하지 않아야 할 상황**을 가리킨다.

### 에러(Error)
- `Error`및 그 하위. **JVM/시스템 레벨의 심각한 문제**(예: `OutOfMemoryError`)로 **애플리케이션에서 던지거나 복구하려 해선 안 됨.**

## 기준: 복구 가능성

### 복구 가능
- 호출자가 실패 원인에 대응해 적절한 조치를 취할 **현실적인 시나리오**가 있다면 **검사 예외**를 던진다.
- 예: 파일/네트워크 일시 실패 -> 재시도, 대체 자원 사용, 사용자에게 경로 재선택 요청 등.
- 이 때 **문서(throws Javadoc)에 복구 방법의 힌트**(무엇을 고치거나 재시도하라)를 함께 제공하는 것이 바람직.

### 복구 불가(프로그래밍 오류)
- 잘못된 인자, 순서 위반, 객체 상태 불일치 등은 **런타임 예외**로 신호화한다.

> **핵심**: 호출자가 합리적으로 복구할 수 있으면 `검사 예외` 그렇지 않으면 `런타임 예외`

## 왜 이렇게 나눌까
- **검사 예외는 처리 강제**를 통해 복구 가능 경로를 API 차원에서 **의도적으로 드러낸다.**
- **런타임 예외는 버그 신호**로 취급되어 **빠르게 실패(fail-fast)**하게 만들고, 문제를 조기에 드러낸다.
- **에러는 애플리케이션이 관여할 대상이 아니다**

## 예외를 어떻게 사용해야 할까

### 검사 예외는 신중하게
- 정말로 호출자가 복구할 **현실적 시나리오**가 있을 때만 사용한다.
- 복구 방안을 제공할 수 없거나, 대부분의 클라이언트가 잡아서 **되돌릴 수 없는 경우**라면 **런타임 예외**가 알맞다.

### 프로그래밍 오류는 런타임 예외
- 전제조건 위반(잘못된 인자, 상태, 호출 순서)은 `RuntimeException` 하위 예외를 사용한다.

### 에러는 건드리지 말자
- `Error`를 **직접 던지지 말고**, 잡으려고 하지도 말자.

### API 문서화
- 검사 예외를 던진다면 **언제 발생하는지와 호출자가 무엇을 할 수 있는지**를 `@throws`에 명확히 기록한다.
- 복구 힌트가 없는 검사 예외는 사용자를 불필요하게 괴롭힌다.

## 핵심
- 복구할 수 있는 상황이면 검사 예외
- 프로그래밍 오류 or 확실하지 않다면 비검사 예외
- throwable은 정의하지도 말자
- 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.