:trophy: 이펙티브 자바 스터디 - 아이템 49

:book: 아이템 49: 매개변수가 유효한지 검사하라

## 핵심
- **공개(public) 메서드/생성자**는 **들어온 매개변수의 요효성을 즉시 검사**하고, 위반 시 **명확한 예외**(메세지 포함)를 던져라 -> **fail-fast**
- 검사를 통해 **클래스 불변식**을 지키고, 오류를 **발생 지점에서** 드러내면 디버깅/유지보수 비용이 급감한다.
- **예외 타입을 올바르게 선택하자**
  - `NullPointerException`(필수 파라미터 null) - 보통 `Objects.requireNonNull`
  - `IllegalArgumentException`(범위/형식 위반)
  - `IndexOutOfBoundsException`(인덱스/범위 위반)
- **비공개(private) 메서드**에서는 종종 `assert`로 내부 가정만 확인해도 충분하다(성능/간결성). 공개 API에는 `assert`로 대체하지 말 것.

## 잘못된 예 -> 개선 예

### 도메인
```java
enum MemberGrade { BRONZE, SILVER, GOLD, PLATINUM }

class Member {
    private final String name;
    private final int age;
    private final MemberGrade grade;

    Member(String name, int age, MemberGrade grade) {
        // (나쁜 예) 아무 검증 없음 — 이후 NPE/깨진 상태로 전파
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}
```

### 개선: 생성자에서 즉시 검증
```java
Member(String name, int age, MemberGrade grade) {
    this.name = Objects.requireNonNull(name, "name must not be null");
    if (name.isBlank()) throw new IllegalArgumentException("name must not be blank");
    
    if (age < 0) throw new IllegalArgumentException("age must not be negative");
    this.age = age;
    
    this.grade = Objects.requireNonNull(grade, "grade must not be null");
}
```

### 서비스 메서드에서의 범위/상태 검증

```java
public List<Member> findByGradeAndAgeRange(List<Member> members,
                                           MemberGrade grade,
                                           int minAgeInClusive,
                                           int maxAgeInClusive) {
    Objects.requireNonNull(members, "members must not be null");
    Objects.requireNonNull(grade, "grade must not be null");
    
    if (minAgeInClusive < 0) throw new IllegalArgumentException("minAgeInClusive must not be negative");
    if (maxAgeInClusive <= minAgeInClusive) {
        throw new IllegalArgumentException("maxAgeInClusive must be greater than minAgeInClusive");
    }

    return members.stream()
            .filter(m -> m.getGrade() == grade)
            .filter(m -> m.getAge() >= minAgeInClusive && m.getAge() < maxAgeInClusive)
            .toList();
}
```

## 표준 도구 모음
- `Objects.requireNonNull(arg, "msg")`/ `requireNonNullElse(...)`
  - **null 즉시 차단**, 예외 메세지로 **어느 파라미터가 문제인지** 드러냄.
- **인덱스/범위 검증(Java 9+)**
  - `Objects.checkIndex(index, length)`
  - `Objects.checkFromToIndex(from, to, length)`
  - `Objects.checkFromIndexSize(from, size, length)`
- `assert condition : "explanation"`
  - **private** 메서드에서 내부 가정 확인용(공개 API X). 런타임 기본 비활성화.

```java
// 예: 부분 리스트 생성에 안전한 범위 검사
public static <T> List<T> safeSubList(List<T> list, int from, int to) {
    Objects.requireNonNull(list, "list must not be null");
    Objects.checkFromToIndex(from, to, list.size());
    return list.subList(from, to);
}
```

## 예외 타입 매핑 정리
| 상황           | 던질 예외                                     | 예시 메시지                                     |
| ------------ | ----------------------------------------- | ------------------------------------------ |
| 필수 파라미터 null | `NullPointerException`                    | `"grade must not be null"`                 |
| 값의 형식/범위 위반  | `IllegalArgumentException`                | `"age must be >= 0: " + age`               |
| 인덱스/범위 위반    | `IndexOutOfBoundsException` (체크 유틸 사용 권장) | 자동 메시지 또는 `"index: " + i + ", size: " + n` |
| 현재 객체 상태 부적절 | `IllegalStateException`                   | `"cannot register: service is closed"`     |

## 문서화(자바독)

### 언제 적을까?

- **공개 API**에서 **매개변수 유효성 검사 실패로 발생할 수 있는 예외**를 모두 `@throws`로 **명확히 문서화**한다.
- 대부분 **런타임 예외**(NPE,IAE,IOOBE 등)지만, 체크 예외가 아니어도 `@throws` 태그로 문서화 한다.
  - `throws`절(시그니처)와 **무관하게** `@throws`는 **문서**다.

### 어떻게 적을까?
- `@throws NullPointerException if grade is null`
- `@throws IllegalArgumentException if age is negative`
- **무엇이 잘못되면**(조건) **어떤 예외가 발생**하는지 **하나씩** 분리해서 기술

### 권장 원칙
- **사전 조건**(preconditions)을 `@param`과 함게 **중복 없이** 일관되게 설명
  - `@param age must be >= 0` + `@throws IllegalArgumentException if age is negative`
- **메세지에 실제 값 포함**(코드에서는) -> 디버깅 용이
- 오버라이딩 시 **사전조건을 강화하지 말 것(LSP)**. 문서도 일관 유지
- 팀 규약으로 **예외 타입/메시지 포맷**을 통일

### 예시) 생성자 자바독 + 유효성 검사

```java
/**
 * 변경 불가능한 Member를 생성한다.
 *
 * @param name  회원 이름(공백 불가)
 * @param age   나이(0 이상)
 * @param grade 회원 등급(null 불가)
 * @throws NullPointerException name이나 grade가 null인 경우
 * @throws IllegalArgumentException name이 공백이거나 age가 음수인 경우
 */
public Member(String name, int age, MemberGrade grade) {
  this.name = Objects.requireNonNull(name, "name must not be null");
  if (name.isBlank()) throw new IllegalArgumentException("name must not be blank");

  if (age < 0) throw new IllegalArgumentException("age must not be negative");
  this.age = age;

  this.grade = Objects.requireNonNull(grade, "grade must not be null");
}
```

### 예시) 서비스 메서드 자바독 + 범위 검사

```java
/**
 * 주어진 등급과 나이 범위 [minAgeInclusive, maxAgeExclusive)에 해당하는 회원 목록을 반환한다.
 *
 * @param members        소스 리스트(null 불가)
 * @param grade          대상 등급(null 불가)
 * @param minAgeInclusive 최소 나이(0 이상)
 * @param maxAgeExclusive 최대 나이의 배타적 경계(minAgeInclusive보다 커야 함)
 * @return 필터링된 회원 목록(never null)
 * @throws NullPointerException members나 grade가 null인 경우
 * @throws IllegalArgumentException minAgeInclusive가 0 미만이거나,
 *                                  maxAgeExclusive가 minAgeInclusive 이하인 경우
 */
public List<Member> findByGradeAndAgeRange(List<Member> members,
                                           MemberGrade grade,
                                           int minAgeInclusive,
                                           int maxAgeExclusive) {
  Objects.requireNonNull(members, "members must not be null");
  Objects.requireNonNull(grade, "grade must not be null");

  if (minAgeInclusive < 0) throw new IllegalArgumentException("minAgeInClusive must not be negative");
  if (maxAgeExclusive <= minAgeInclusive) {
    throw new IllegalArgumentException("maxAgeInClusive must be greater than minAgeInClusive");
  }

  return members.stream()
          .filter(m -> m.getGrade() == grade)
          .filter(m -> m.getAge() >= minAgeInclusive && m.getAge() < maxAgeExclusive)
          .toList();
}
```

### 주의할 점
- `@throws Exception` 같은 **포괄 문서화 금지** -> 구체 타입/조건을 나열
- 공개 API에서 `assert`만 쓰고 `@throws` 생략 -> 런타임에서 깨지면 검증 누락
- **동일한 도메인 규칙**은 유틸 메서드로 재사용 + `@throws` 설명을 반복 일원화
- **변경 시 영향**: 공개 API의 예외 계약은 사실상 API 계약이므로 **호환성** 고려하며 변경

## Bean Validation과의 조합 (선택)
- 컨트롤러/DTO 레벨에선 `Jakarta Bean Validation`(`@NotNull`, `@Min`, `@Max`, `@Pattern`)이 **표준적이고 편리.**
- **도메인 내부**(엔티티/불변식)는 **직접 검사 + 올바른 예외**가 더 명확(프레임워크 의존도 감소, 즉시 실패)

```java
// DTO 예시
record CreateMemberRequest(
        @NotBlank String name,
        @Min(0) int age,
        @NotNull MemberGrade grade
) {}
```

### 실수 패턴
- "나중에 쓰다 보면 알아서 NPE 나겠지" -> **늦은 실패**로 원인 추적 어려움
- 애매한 메세지/한줄짜리 잘못된 값 -> **어떤 값이 문제인지**를 반드시 포함.
- 공개 API에서 `assert` 남용 -> 런타임에서 꺼질 수 있어 **검증 누락** 위험.
- **입구에서 즉시 검증 + 정확한 예외/메세지 + 자바독 사전 조건.**

## 정리

### 검사 비용이 성능에 영향을 줄까?
- 대부분의 경우 **미미**. 실패를 초기에 잡아주는 이점이 훨씬 크다

### Optional을 매개변수로 받아 null 회피?
- 권장하지 않음. 매개변수는 보통 **필수/선택**을 명확히 나누고, **필수는 null 금지 + 즉시 검사**

### 체크 유틸이 따로 필요할까?
- 프로젝트 공통 `Preconditions` 유틸 (예: `CheckPositive`, `CheckNotBlank`)을 만들어 **일관된 메세지/예외**를 재사용하면 코드가 깔끔해진다.

> **공개 API의 모든 파라미터는 입구에서 즉시 검증하자.**  
> 적절한 예외 타입과 구체적 메세지로 **fail-fast**, 클래스 불변식을 보호하고 디버깅 시간을 줄여라.  
> 내부(private) 로직에 한해 `assert`로 가정을 확이나되, 공개 API에서는 반드시 예외 검증을 수행하자.