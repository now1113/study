:trophy: 이펙티브 자바 스터디 - 아이템 53

:book: 아이템 53: 가변인수는 신중히 사용하라


## 핵심
- **가변인수 메서드는 호출 때마다 배열을 1개 생성**한다 -> 자잘하게 많이 호출되면 비용이 된다.
- **인수를 최소 N개 이상 요구**하는 경우, 단순 `T...`만 쓰면 런타임에서야 실패한다.
  - **필수 인수 + varargs 패턴**으로 **컴파일 타임 계약**을 드러내라.
- **성능이 중요한 API는 소수 구간(0~3개 등) 오버로드 제공 + 나머지 varargs**로 연결하자.
  - `EnumSet.of`가 여러 오버로드를 제공한 뒤 varargs로 이어준다

## 예시: 최소 1개 이상 요구하는 min
> `int...` 만 두면 **빈 배열 호출이 컴파일은 되고**, 런타임에서야 실패한다.

### 나쁜 예
```java
static int min(int... args) {
    if (args.length == 0) {
        throw new IllegalArgumentException("1개 이상 필요");
    }
    int min = args[0];
    for (int i = 1; i < args.length; i++) {
        if (args[i] < min) {
            min = args[i];
        }
    }
    return min;
}
```

### 개선 - 필수 인수 + varargs 패턴
```java
static int minV2(int first, int... rest) {
    int min = first;
    for (int x : rest) {
        if (x < min) {
            min = x;
        }
    }
    return min;
} 
```

## 예시: 성능 고려 -> 오버로드 + varargs 폴백
> 가변인수는 **매 호출 시 배열 1개가 생성**된다. **빈번한 호출**이거나 **핫패스**라면 피로가 쌓인다.  
> `EnumSet.of(...)`는 1~5개 정도는 **오버로드**로 처리하고, 그 이상은 **varargs**로 받는다.

```java
static void log(String a1) {
    
}
static void log(String a1, String a2) {
    
}
static void log(String a1, String a2, String a3) {
    
}

static void log(String a1, String a2, String a3, String... rest) {
    
}
```
> 이렇게 하면 **일반적인 짧은 호출**에서 **배열 생성이 없다.**  
> (진짜로 핫패스 일 때만 적용. 대부분은 단순 varargs로 충분)


## 예제: Member

### 한 명 이상은 꼭 필요한 알림 전송

```java
public void notify(Level level, Member first, Member... others) {
    send(level, first);
    for (Member m : others) {
        send(level, m);
    }
}
```

### 포매팅 로그 (자주 호출되는 경우 오버로드 + varargs)
```java
static void out(Level level, String message) {
    
}

static void logf(Level level, String message) {
    out(level, message);
}

static void logf(Level level, String message, Object a1) {
    out(level, message.formatted(a1));
}

static void logf(Level level, String message, Object a1, Object a2, Object... rest) {
    out(level, message.formatted(a1, a2, rest));
}
```

## 오버로딩과 varargs 충돌 주의

### 모호/의외의 선택을 만든 예

```java
static void save(Member... ms) {
    System.out.println("save1");
}

static void save(String path, Member... ms) {
    System.out.println("save2");
}

public static void main(String[] args) {
    save("data");   // 두 번째 메서드 (빈 varargs)
    save();         // 첫 번째 메서드 (빈 varargs)
}
```
- 호출 의도와 선택이 항상 명확하진 않다.
- **이름 분리**가 더 낫다. ex) `saveAll(Member...)`, `saveTo(String, Member...)`

## 제네릭과 varargs
- 제네릭 varargs는 **힙 오염 경고**가 날 수 있다 -> **안전함을 보장할 수 있을 때만** `@SafeVarargs`
- 라이브러리 메서드에선 **가능하면 제네릭 varargs를 피하고** 컬렉션을 받는 것을 고려하자.


## 요약

> **varargs는 편리하지만 값 1개 배열 생성이라는 비용이 항상 있다.**  
> 최소 인수 제약은 **필수 인수 + varargs**로 **컴파일 타임에 드러내고**,  
> 성능상 민감한 API는 **소수 오버로드 + varargs 폴백**으로 최적하하라.  
> 오버로딩과 섞일 때의 **모호성**도 늘 경계하자.