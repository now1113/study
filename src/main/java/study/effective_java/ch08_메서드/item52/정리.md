:trophy: 이펙티브 자바 스터디 - 아이템 52

:book: 아이템 52: 다중정의는 신중히 사용하라


## 핵심
- **오버로딩은 컴파일 타임에 `정적 타입`으로 결정**된다. (오버라이딩은 런타임 동적 디스패치)
- 매개변수 **개수는 같고 타입만 다른** 오버로드를 많이 두면 호출자가 **의도치 않은 메서드**를 호출하기 쉽다.
- `null` 인수, **오토박싱/언박싱**, **가변 인수**는 혼동을 키운다.
- 해법은 **이름을 구분**하거나, **하나의 메서드로 통합**해 내부 분기를 쓰자.


## 예시: CollectionClassifier
> 포인트: 반복 변수의 **정적 타입**이 무엇이냐에 따라 **오버로드 선택이 고정**된다.

```java
public class CollectionClassifier {
    
    public static String classify(Set<?> s) {
        return "Set";
    }

    public static String classify(List<?> l) {
        return "List";
    }

    public static String classify(Collection<?> c) {
        return "Collection";
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {
                new HashSet<String>(),
                new ArrayList<String>(),
                new HashSet<String>(),
        };

        for (Collection<?> collection : collections) {
            System.out.println(classify(collection));
        }
    }
}
```
```java
Collection
Collection
Collection
```

### 왜 이렇게 나올까
- `for` 루프 변수의 **정적 타입이** `Collection<?>` 이기 때문.
- 오버로딩 결정은 **컴파일 시점**에 끝나서, 항상 `classify(Collection<?>)`가 호출된다.

### 개선: 오버로드 통합 + 내부 분기
```java
public static String classify(Collection<?> c) {
    if (c instanceof Set) {
        return "Set";
    }
    if (c instanceof List) {
        return "List";
    }
    return "Collection";
}
```
- 하나의 진입점으로 **의도한 대로** 분기된다.
- 또는 메서드명을 아예 구분 ex) `classifySet`, `classifyList` 해서 **모호성 제거.**


## 예시: List.remove 함정 (오토박싱 + 오버로딩)
> **포인트:** 이름, 같은 개수, **매개변수 타입만 다른** 오버로드는 위험.

```java
List<Integer> nums = new ArrayList<>(List.of(1, 2, 3));
// remove(int index) vs remove(Object o)

nums.remove(1);                  // 인덱스 1의 원소 제거 → 값 2가 사라짐
nums.remove(Integer.valueOf(1)); // 값 1 제거
```
- API를 설계할 때 이런 혼동을 낳는 **유사 시그니처 오버로드**는 피하라.
- 호출자는 **의도늘 드러내는 형변환/팩토리**를 써서 명시하라.

## 예시: null 인수와 오버로딩의 모호성
```java
void print(String s)  { System.out.println("String"); }
void print(Object o)  { System.out.println("Object"); }

// print(null);  // 컴파일 오류: 모호함
```
- `null`은 **모든 참조 타임에 대입 가능** -> 둘 다 후보가 되어 **모호.**
- 캐스팅으로 의도를 전달 또는 **이름을 분리**하여 해결 ex) `print((String) null);`

## 정리
- **다른 의미/동작이면 이름도 다르게** ex) `findById`, `findByName`
- **매개변수 개수가 같고 타입만 다른 오버로드**를 가급적이면 두지 말자
- `null` **가능성이 있나?** -> 모호성 제거(이름 분리/전용 타입)
- **오토박싱/언박싱 개입** 여부를 점검(특히 컬렉션 API)
- **varargs**와 다른 오버로드의 **충돌**을 피한다
- 문서/테스트에서 **경계 케이스**(null, 방식, 서브타입, 빈 컬렉)를 꼭 검증하자.


> **오버로딩 선택은 컴파일 타임의 정적 타입에 좌우된다.**    
> 같은 이름, 같은 개수, 유사 타입 오버로드는 **모호성과 오해**를 낳는다.  
> **이름을 분리**하거나 **하나로 통합해 내부 분기**하자.  
> `null`, 오토박싱, varargs는 특히 주의히자.