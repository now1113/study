:trophy: 이펙티브 자바 스터디 - 아이템 50

:book: 아이템 50: 적시에 방어적 복사본을 만들라

## 핵심
- **클래스 불변식**을 깨드릴 수 있는 **가변 객체**(배열, 컬렉션, Date, 커스텀 가변 타입)가 매개변수/필드/반환값으로 드나든다면 **반드시 방어적 복사**를 고려하자.
- **생성자, 팩토리, 세터**: **받을 때 복사
- **접근자(getter)**: **복사/불변 뷰**가 원칙
- **검사 순서 주의**: **복사를 먼저**하고 **그 다음 유효성 검사**(TOCTOU 방지)
- **clone()에 의존하지 말고**(하위 타입 오염 위험), **복사 생성자/팩토리**나 표준 유틸을 쓰자.
- 가능하면 **처음부터 불변 타입**(예: `LocalDate/Instant`,`List.copyOf`)을 사용해 복사 비용 자체를 줄이자


## 필요한 이유
- **생성자 인자로 받은 가변 객체**가 외부에서 나중에 수정되면 **이미 생성된 객체의 불변식이 깨짐.**
- **getter가 내부 가변 필드의 참조를 그대로 노출**하면, 클라이언트가 **내부 상태를 직접 변경**해버릴 수 있음.
- 다중 스레드 환경에서는 **경합과 예측 불가능한 상태**로 이어짐.


## 잘못된 예 -> 개선 예

```java
// 가변 타입
class Address {
    private String city;
    private String street;
    // setter 포함 (가변)
    // getters/setters...
}
```

### 잘못된 설계: 외부 가변 객체 그대로 저장 + 내부 노출
```java
public class Member {
    private final String name;
    private final int age;
    private final MemberGrade memberGrade;
    private final Address address;
    private final List<String> roles;

    public Member(String name, int age, MemberGrade memberGrade, Address address, List<String> roles) {
        this.name = name;
        this.age = age;
        this.memberGrade = memberGrade;
        this.address = address;             // 그대로 저장 (취약)
        this.roles = roles;                 // 그대로 저장 (취약)
    }

    public Address getAddress() {
        return address;
    }

    public List<String> getRoles() {
        return roles;
    }
}
```
- 외부에서 `address.setCity("...")`, `roles.add("...")` 호출하면 **Member 내부 상태가 변함**

### 개선: 받는 쪽 복사 + 주는 쪽 복사/불변 뷰
```java
final class Member {
    private final String name;
    private final int age;
    private final MemberGrade grade;
    private final Address address;        // 내부 복사본
    private final List<String> roles;     // 불변 뷰

    Member(String name, int age, MemberGrade grade, Address address, List<String> roles) {
        this.name   = Objects.requireNonNull(name);
        if (age < 0) throw new IllegalArgumentException("age >= 0");
        this.age    = age;
        this.grade  = Objects.requireNonNull(grade);

        // 1) 먼저 복사본 생성(TOCTOU 방지)
        this.address = copyOf(address);
        // 2) 유효성 검사(예: city/street 형식 등)
        validate(this.address);

        // JDK 10+: 입력 컬렉션을 방어적 복사 + 불변화
        this.roles = List.copyOf(Objects.requireNonNull(roles));
    }

    // Address 방어적 복사(복사 생성자/팩터리 패턴 권장)
    private static Address copyOf(Address src) {
        Objects.requireNonNull(src);
        Address x = new Address();
        x.setCity(src.getCity());
        x.setStreet(src.getStreet());
        return x;
    }

    private static void validate(Address a) {
        if (a.getCity() == null || a.getCity().isBlank()) {
            throw new IllegalArgumentException("city required");
        }
        // 기타 규칙...
    }

    // 1) 가변 객체는 '복사본' 반환
    public Address getAddress() {
        return copyOf(address);
    }

    // 2) 컬렉션은 '불변 뷰' 반환(이미 List.copyOf로 불변)
    public List<String> getRoles() {
        return roles;
    }
}
```
- **입력 시 복사 -> 내부는 안전**
- **반환 시 복사/불변 뷰 -> 외부에서 내부 변경 불가**

## 타입별 방어적 복사 베스트 프랙티스

### 날짜/시간
- `java.util.Date`, `Calendar`는 가변 -> **쓰지 말고** `Instant/LocalDate/LocalDateTime/ZonedDateTime` 같은 **불변**을 사용하자.
  - 불가피하게 `Date`를 받아야 한다면
    - 입력: `this.date = new Date(requireNonNull(date).getTime())`
    - 반환: `return new Date(this.date.getTime())`

### 배열
- 입력 시: `this.arr = arr.clone();`(또는 `Arrays.copyOf`)
- 반환 시: `return arr.clone()`
- 배열 요소가 **가변 객체**라면 **깊은 복사**(요소 단위 복사) 고려.

### 컬렉션
- 입력 시: `List.copyOf(src)`, `Set.copyOf(src)`, `Map.copyOf(src)`
- 반환 시: 이미 불변으로 보관중이면 그대로 반환, 아니면 `Collections.unmodifiable*`로 감싸서 반환

### 커스텀 타입
- **복사 생성자/정적 팩터리**를 제공해 방어적 복사 표준화

```java
class Address {
    Address(Address src) { ... }              // 복사 생성자
    static Address copyOf(Address src) { ... } // 정적 팩터리
}
```
- 신뢰 경계 넘어오는 모든 경로에서 이를 사용.


## 순서가 중요하다 (TOCTOU 방지)
- **나쁜 순서**: 검사 -> (사이 사이 외부에서 원본 변경) -> 복사
- **좋은 순서**: **복사 -> 검사**
  - 복사 중간에 외부가 원본을 바꿔도 **내부 복사본은 안전.**


## clone()에 의존하지 말자
- 매개변수의 **실제 런타임 타입이 하위 타입**일 수 있으며, 그 타입의 `clone()`이 **오염된 구현**일 가능성.
- **명시적 복사 생성자/팩토리**가 더 안전하고 의도가 분명하다.

## 언제 방어적 복사를 생략할 수 있을까?
- **완전히 신뢰되는 내부 호출 경로(패키지 내부 전용 등)에서 성능이 절실하고, 계약상 가변 노출이 없음을 보장할 때.
- 단, 공개 API, 모듈 경계에서는 **항상 방어적 복사를 기본값으로 하자.**


## 요약
> **가변 데이터가 경계를 넘나들면, `받을 때 복사, 줄 때 복사/불변화 `가 기본 규칙이다.    
> 복사 후 검사(TOCTOU 방지), clone() 대신 복사 생성자/팩토리, 가능하면 처음부터 불변 타입 사용.  
> 공개 API에서 방어적 복사는 **신뢰성과 불변식**을 지키는 가장 값싼 보험이다