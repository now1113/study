:trophy: 이펙티브 자바 스터디 - 아이템 51

:book: 아이템 51: 메서드 시그니처를 신중히 설계하라

## 핵심
- **이름은 명확하게, 일관되게.** 표준 관례(자바/컬렉션/스프링 등)와 도메인 용어를 따른다.
- **파라미터 수는 적게.** 4개를 넘기기 시작하면 냄세. -> **분리 파라미터 객체, 빌더** 고려.
- **가장 일반적인 인수 타입을 받되(인터페이스/상위 타입)**, 의미 있는 **전용 값 타입**(예:`LocalDate`,`Duration`,`Path`,`Currency`)을 적극 사용해 **오용을 방지한다.**
- **불분명한 플래그 인수(boolean) 금지.** 의미가 갈리는 경우 **메서드 분리** 또는 **옵션 enum**을 사용하자.
- **같은 타입 인수가 여러 개면 순서 실수 위험 증가.** 전용 타입으로 래핑하거나 시그니처를 재설계.
- **편의 메서드는 `최소한으로`.** API 표면적을 불필요하게 넓히지 말자

## 잘못된 예 -> 개선 예

### 1) 불명확한 이름 & 플래그 인수
```java
// 무엇을 하는지 모호 + boolean 플래그로 의미가 갈림
public List<Member> process(MemberGrade memberGrade, boolean includeInactive) {
    return null;
}
```
```java
private enum Scope {
    ACTIVE_ONLY, INCLUDE_INACTIVE
}
// 역할을 분명히 분리
public List<Member> findActiveByGrade(MemberGrade memberGrade) {
    return null;
}
public List<Member> findAllByGrade(MemberGrade memberGrade) {
    return null;
}
// enum으로 의도 명확화
public List<Member> findByGrade(MemberGrade memberGrade, Scope scope) {
    return null;
}
```

### 2) 파라미터 과다
```java
// 파라미터 7개, 가독성/호출 실수 위험
public List<Member> search(MemberGrade memberGrade,
                           Integer minAge,
                           Integer maxAge,
                           String city,
                           String keyword,
                           int page,
                           int size) {
    return null;
}
```
```java
public final class MemberSearchCriteria {
    private final MemberGrade memberGrade;
    private final Integer minAge;
    private final Integer maxAge;
    private final String city;
    private final String keyword;
    private final int page;
    private final int size;

    public MemberSearchCriteria(MemberGrade memberGrade, Integer minAge, Integer maxAge, String city, String keyword, int page, int size) {
        this.memberGrade = memberGrade;
        this.minAge = minAge;
        this.maxAge = maxAge;
        this.city = city;
        this.keyword = keyword;
        this.page = page;
        this.size = size;
    }
}
// 시그니쳐가 단순해짐
public List<Member> search(MemberSearchCriteria memberSearchCriteria) {
    return null;
}
```

### 3) 가장 일반적인 타입을 받기
```java
// 구체 컬렉션에 종속
public void registerAll(ArrayList<Member> batch) {

}
```
```java
public void registerAll(List<Member> batch) {
    
}
```

### 4) 전용 값 타입 사용으로 오용 방지
```java
// 문자열로 날짜/기간/경로를 받으면 형식, 시간대 검증 지옥
public List<Member> findJoinedBetween(String from, String to, String tz) {
    return null;
}
```
```java
// 의미 있는 타입으로 받기
public List<Member> findJoinedBetween(LocalDate from,  LocalDate to, ZoneId tz) {
    return null;
}
```

### 5) 같은 타입 인수 여러 개 -> 순서 실수 방지
```java
// 둘 다 String -> 호출부에서 바꿔 넣어도 컴파일 OK, 런타임 버그
public void reanme(String oldName, String newName) {

}
```
```java
// 전용 타입 or 메서드명으로 의미를 강하게, 또는 메서드 분리하기
public void rename(MemberName oldName, MemberName newName) {

}
```

## 네이밍 
- **동사 + 목적어**: `findByGrade`, `register`, `deactiveate`, `countActive`
- **집계/조회는 find/get/list/count 구분**
  - `get` = 즉시/존재 보장, `find` = 조건 검색, `list` = 컬렉션 반환, `count` = 수량
- **부가 조건은 접미사로:** `...ByGrade`, `...Between`, `...IncludingInactive`
- **일관된 순서:** 필수 -> 범위/필터 -> 옵션/정렬 -> 페이징

## API 설계 체크리스트
- 메서드 이름만 읽고도 **역할이 명확**한가
- **불필요한 편의 메서드**는 줄였는가
- 파라미터가 많다면 **분해/파라미터 객체/빌더**를 고려했는가
- **인터페이스/상위 타입**을 받고, 내부에서 필요하면 다운캐스팅 없이 사용 가능한가
- **boolean 플래그** 대신 **메서드 분리/옵션 enum**으로 의도를 드러냈는가
- **같은 타입 인수 여러 개**로 순서 실수 위험이 없는가
- `String` 대신 **의미 있는 전용 타입**(`LocalDaete`, `Duration`, 도메인 VO 등)을 사용했는가


## 요약
> **시그니처는 API의 얼굴.**  
> 이름은 명확하고 일관되게, 인수는 적고 의미 있게, 타입은 일반적으로 받되 전용 값 타입으로 오용을 막자.  
> 플래그/과다 인수는 **분리/객체화**로 해소하고, 편의 메서드는 최소한만 제공하자.



