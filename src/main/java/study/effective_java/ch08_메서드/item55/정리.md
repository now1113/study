:trophy: 이펙티브 자바 스터디 - 아이템 55

:book: 아이템 55: 옵셔널 반환은 신중히 하라

## 핵심
- **반환값이 `있을 수도, 없을 수도` 있는 경우**에 한에 `Optional<T>`로 표현하자.
- `없음`이 **정상적인 결과**라면 예외를 던지거나 `null`을 반환하지 말고 `Optional`을 고려하자.
- 다만 **무분별한 사용은 금지**한다, 남용하면 API가 오히려 더 복잡해진다.

## 언제 Optional이 좋을까
- **단일 값**을 찾는 조회 메서드
  - `findById`, `lookup`, `max/min`(스트림 종단 연산) 등
- **정상적인 부재**가 가능한 경우
  - **그 이름의 치즈가 없을 수도 있음**
  - 레거시 API에서 `null`을 반환할 수밖에 없을 때, 경계에서 `Optional.ofNullable(...)`로 감싸 반환하자.

### 예시

```java
public class Refrigerator {
    private List<Cheese> cheeses;

    public Optional<Cheese> findCheese(String name) {
        return cheeses.stream()
                .filter(c -> c.getName().equalsIgnoreCase(name))
                .findFirst();
    }
}
```
사용 측은 다음처럼 안전하고 의도가 분명해준다.

```java
public class Shop {
    private final Refrigerator refrigerator;

    public Shop(Refrigerator refrigerator) {
        this.refrigerator = refrigerator;
    }

    public Cheese findCheese(String name) {
        Cheese defaultCheese = new Cheese("defaultCheese");
        
        return refrigerator.findCheese(name)
                .orElse(defaultCheese);
    }
}
```

## 언제 Optional을 쓰지 말아야 할까
- **다중 값 변환**: `Optional<List<T>>`, `Optional<Set<T>>` 등은 지양
  - 그냥 **빈 컬렉션/배열**을 반환하자.
- **메서드 매개변수, 필드, 컬렉션 요소**로 `Optional`을 쓰지 말자
  - `Optional`은 **반환 전용**으로 설계됐다. 내부 상태 표현엔 부적절하고 **메모리,복잡도 비용**만 늘린다.
  - 예외적으로 `Map<K, Optional<V>>`처럼 `키 존재 + 값 부재`를 **의미적으로 구분해야**하는 드믄경우에는 사용할 수 있다.
- **성능이 매우 중요한 핫패스**
  - `Optional` 객체 생성,해제가 잦으면 비용이 눈에 뛸 수 있다. 필요 시 그냥 `null`을 문서화, 방어적으로 처리하거나, 다른 설계를 탐색하자.
- **Optional을 반환하는 메서드에서 `null`을 절대 반환하지 말자.**

### orElse / orElseGet / orElseThrow

```java
// 기본값이 가볍거나 상수면
T v = opt.orElse(DEFAULT);

// 기본값 계산 비용이 크면 지연 계산
T v = opt.orElseGet(this::heavyFallback);

// 부재가 비정상 상황이면 예외
T v = opt.orElseThrow(() -> new NoSuchElementException("not found"));
```

- `orElse`의 인자는 **항상 평가**된다. 무거우면 `orElseGet`을 사용하자

## 원시 타입과 성능
- 숫자처럼 원시값 한 개를 옵셔널로 반환해야 한다면 **박싱 비용**이 걱정될 수 있다.
  - `OptionalInt`, `OptionalLong`, `OptionalDouble`등 **전용 옵셔널을 고려**하자.
- 다만 전용 옵셔널은 **종류가 제한적**이고 API가 약간 불편하다.
  - **실제 성능 병목에서만 선택**하고, 그 외에는 일반 `Optional<T>`(박싱)도 충분히 실용적이다.

## 스트림과 함께 사용하기
- 종단 연산 `findFirst() / findAny() / max() / min() / reduce()` 등은 자연스럽게 `Optional`을 돌려준다.

```java
Optional<Cheese> maxPriced =
    cheeses.stream().max(comparing(Cheese::price));
```

## 예외/null vs Optional
- **예외**: 부재가 **예외적 상황**일 때만. 정상 부재에 예외를 쓰면 호출자에 비용, 잡음이 크다.
- `null`: API 사용자가 방어 코드를 직접 떠안아야 하고, 실수로 NPE 유발.
- `Optional`: 정상 부재를 **타입 시스템으로 명시**, 호출부를 안전하고 의도대로 이끈다.

## 요약
- **단일 값이 `없을 수도` 있으면 Optional로 반환하되, 남용하지 말라.**
- 컬렉션/배열은 **빈 컨테이너를 반환**
- 매개변수, 필드, 컬렉션 요소로 `Optional`을 쓰지말고, 민감 구간에선 비용을 따져보자.
- `orElse / orElseGet / orElseThrow`를 상황에 맞게 선택하고, 필요 시 `OptionalInt` 등 전용 타입으로 박싱 비용을 피하자.


