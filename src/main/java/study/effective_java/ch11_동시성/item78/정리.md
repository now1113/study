:trophy: 이펙티브 자바 스터디 - 아이템 78

:book: 아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라

## 핵심
여러 쓰레드가 **가변(mutable) 데이터를 공유**한다면, 그 데이터에 대한 **모든 접근(읽기/쓰기)을 동기화(synchronization)로 보호**해야한다.  

동기화는 "겹치지 않게"만이 아니라, **한 스레드의 변경을 다른 스레드가 '보게' 만드는(가시성, visibility)** 목적도 가진다.

## 왜 필요할까: 동기화가 보장하는 2가지

### 배타적 실행(원자성, atomicity)
- 한 번에 하나의 스레드만 임계 구역에 들어가게 해서 **중간 상태 깨짐**을 막는다.
- 예: `count++`는 한 연산처럼 보이지만 실제로는 `읽기 -> 더하기 -> 쓰기`(read-modify-write)라서 동기화 없이 공유하면 깨진다.

### 가시성(visibility)
- 동기화 없는 읽기/쓰기는 CPU 캐시/재정렬/컴파일러 최적화 때문에
  - **다른 스레드의 최신 값을 못 볼 수 있다**
  - 심하면 "절대 끝나지 않는 루프" 같은 현상이 나온다.
- **쓰기만 동기화하고 읽기를 동기화하지 않으면 여전히 깨진다.**
  - (같은 락/같은 규칙으로 읽기/쓰기 둘 다 보호해야 한다)

## 대표적인 실패 패턴: 종료 플래그 (busy-wait)
- 한 스레드가 `stopRequested = true`로 바꾸는데, 다른 스레드가 `while(!stopRequested) {}`에서 **영원히 못 빠져나오는** 상황이 가능하다.
- 이유: 읽는 쪽이 **최신 값을 볼 보장이 없다.**

### 해결책: `synchronzied` (일반적이고 안전한 기본값)
- **읽기/쓰기 모두**를 `synchrinized`로 감싼다.
- 동기화는 **상호배제 + 가시성을 같이 제공**한다.
- 또한 여러 필드에 걸친 불변식(invariant)을 지키기 좋다.

### 해결책: `volatile` (가시성만 필요할 때)
- `volatile`은 **가시성(그리고 재정렬 제한)을 보장**한다.
- 하지만 **원자성을 보장하지는 않는다.**
  - `volatile int x; x++;` 는 여전히 안전하지 않다.
- 따라서 `volatile`은 보통 **단순 상태 플래그(켜짐/꺼짐)** 같은 단일 읽기/쓰기에 적합하다.

### 해결책: 고수준 동시성 도구 사용 (권장)
- `AtomicLong`, `LongAdder` 같은 원자 클래스는 동기화의 복잡도를 낮추고 성능도 좋은 경우가 많다.
- "공유 가변 상태" 자체를 줄이는 방향이 가장 좋다.
  - 불변 객체(immutable)로 만들기
  - 스레드 한정(thread confinement) / 지역 변수로 가두기
  - 이미 동시성 설계가 된 컬렉션/구성요소 사용

## 정리
- **여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야 한다.**

