# 재정렬(Reordering)

`재정렬(Reordering)`은 **코드에 적힌 실행 순서(프로그램 순서)와 실제로 CPU/JIT/컴파일러가  
실행, 메모리에 반영하는 순서(관측 가능한 순서)가 달라질 수 있는 현상**이다.

## 핵심
- **단일 스레드 관점**에서는 결과가 같도록(=의미가 보존되도록) 최적화해도 문제 없음
- 그런데 **다른 스레드가 동시에 그 값을 읽으면**, 그 최적화된 순서 때문에 **이상한 형태를 볼 수 있다.**
- 그래서 공유 가변 데이터는 `synchronized`/`volatile`/원자 클래스 등으로 **happens-before(발생-이전)** 관계를 만들어서 "보는 순서"를 강제해야 한다.

## 재정렬이 왜 생길까

### 컴파일러/JIT
- 서로 의존성 없는 연산을 바꾸거나, 루프 밖으로 값을 끌어올리는 최적화 등

### CPU 실행 (Out-of-order execution)
- CPU가 더 빨리 실행하려고 명령을 내부적으로 앞뒤로 실행하기도 함

### 메모리 시스템(가시성 관점)
- CPU는 성능 때문에 **store buffer** 같은 걸 사용해서 "쓴 값이 메모리에 바로 반영되지" 않을 수 있다.
- 그래서 **다른 스레드가 관측하는 write 순서가 뒤바뀐 것처럼 보일 수 있다.**


## 재정렬을 막는 방식

### volatile
`volatile`은 "그 변수 기준으로 앞뒤 메모리의 연산의 관측 순서"를 강하게 만든다.

- `volatile` **write**: 그 이전에 한 일반 write들이 **먼저 보이도록(release)**
- `volatile` **read**: 그 이후의 일반 read들이 **최신을 보도록(acquire)**

> 단, `volatile`은 **가시성/순서**에 강하고, `count++;` 같은 **복합 연산 원자성**까지 해결해주지 않는다.

### synchronized
- **상호배제(원자성) + 가시성/순서 보장**을 같이 준다.
- 여러 필드 불변식(invariant)을 함께 지켜야 할 때는 보통 `synchroinzed`가 더 안전한 기본값이다.

## 정리

재정렬은 "실행 순서가 바뀐다"기 보다, **다른 스레드가 메모리를 관측하는 순서가 바뀔 수 있다**는 게 핵심이다.  
이를 막으려면 **happens-before를 만드는 동기화**가필요하다.