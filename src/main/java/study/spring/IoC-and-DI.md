# IoC (Inversion of Control) & DI (Dependency Injection)

## IoC (Inversion of Control) - 제어의 역전

### 정의
> 객체의 생성, 생명주기, 의존성 관리를 개발자가 직접 하지 않고 **Spring Container가 대신 관리하는 설계 원칙**

- 기존에는 개발자가 객체를 만들고 사용하는 흐름을 전부 제어했지만
- **IoC를 적용하면** 객체의 생성과 주입은 **Spring이 담당**하고, 개발자는 로직에 집중할 수 있음
- 제어권이 **개발자 -> 프레임워크로 역전**
- Spring은 Bean 객체를 생성하고, 필요한 의존 객체도 대신 주입해줌

## DI (Dependency Injection) - 의존성 주입

### 정의
> IoC를 **구현하는 구체적인 방법**으로, 객체가 필요로 하는 의존성을 **외부(Spring)가 주입하는 방식**

### 주입 방식

| 방식     | 설명                       | 추천 여부              |
| ------ | ------------------------ | ------------------ |
| 생성자 주입 | 생성자를 통해 주입               |  가장 안전하고 권장        |
| 필드 주입  | 필드에 직접 주입 (`@Autowired`) |  테스트 어려움, final 불가 |
| 세터 주입  | Setter 통해 주입             |  선택적 의존성에 유용     |

### IoC / DI 흐름 요약

```text
1. @Component, @Service 등으로 Bean 등록
↓
2. ApplicationContext가 Bean 생성
↓
3. 생성자/필드/세터를 통해 의존성 주입
↓
4. Bean 사용 가능
```

### 객체 제어 구조 비교

```text
개발자가 직접 제어 (IoC X):

[OrderService] → new OrderRepository()

Spring이 제어 (IoC 적용):

[ApplicationContext]
        ↓
[OrderService] ← OrderRepository 자동 주입
```


## 결론

| 요약                                 |
| ---------------------------------- |
| IoC는 설계 원칙, DI는 그 구현 방법이다          |
| Spring은 IoC 컨테이너로서 DI를 통해 객체를 관리한다 |
| 생성자 주입이 가장 안전하고 실무에서 널리 사용된다       |



## 심화 질문

### IoC는 어떤 문제를 해결하기 위해 등장했나요?
- **객체 생성 책임을 개발자가 직접 가지면** 코드가 **강하게 결합되고** 테스트가 어려움
- IoC는 객체 생성과 생명주기 관리를 **프레임워크가 담당하게 함으로써 유연한 설계를 가능하게 함**

### DI는 IoC를 어떻게 실현하나요?
- 객체를 직접 new 하지 않고, 필요한 의존 객체를 **컨테이너가 주입**함으로써 구현

### 생성자 주입을 권장하는 이유는?
- 테스트 시 Mock 객체 주입이 가능
- 의존성이 누락되었을 경우 컴파일 타임에 확인 가능
- 불변성 유지(`final` 사용)

### DI 없으도 개발은 가능한데 왜 써야 하나요?
- **의존성 제어 권한이 분리되어 유연한 설계 가능**
- 테스트 용이성, 유지보수성, 확장성 모두 향상됨.