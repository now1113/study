# 메모리 단편화 (Memory Fragmentation)

## 정의
**메모리 단편화**란, 메모리 전체 공간은 충분히 있지만 **연속적인 할당이 불가능한 상태**를 의미한다.  
이로 인해 시스템은 더 이상 메모리를 **효율적으로 할당하지 못하고**, 성능 저하 혹은 OOM(OutOfMemory)이 발생할 수 있다.

> 핵심:  
> 전체 공간은 넉넉한데, **조각나 있어서** 큰 덩어리를 못 넣는 상황

## 단편화의 종류
| 구분                                  | 설명                                                       | 비유                                    | JVM/OS 관점 예시                                                                                |
| ----------------------------------- | -------------------------------------------------------- | ------------------------------------- | ------------------------------------------------------------------------------------------- |
| **외부 단편화 (External Fragmentation)** | 메모리 해제 후 남은 빈 공간들이 서로 떨어져 있어서 연속된 큰 블록 할당이 어려운 상태        | 서랍에 여러 칸이 비어있지만, 큰 책을 넣을 만한 연속된 칸이 없음 | JVM에서 객체들이 생겼다 사라지면서 heap에 빈 공간이 흩어짐. 특히 `Mark-Sweep` 단계 후 `Compact`를 하지 않으면 발생             |
| **내부 단편화 (Internal Fragmentation)** | 고정된 크기의 블록을 할당했지만, 실제 필요한 양보다 크게 할당되어 **남는 공간이 낭비**되는 상태 | 1리터 생수통에 600ml만 넣은 경우, 400ml는 낭비됨     | 4KB 페이지 할당 단위로 OS가 관리할 때, 1KB만 써도 3KB는 낭비됨. JVM의 `Thread Stack`, `TLAB` 같은 고정 크기 구조에서 발생 가능 |

## 단편화가 발생하는 이유

### 외부 단편화
- 동적 메모리 할당/해제가 반복되며 빈 공간이 생김
- 할당할 수 있는 공간은 존재하나 **요청 크기만큼 연속된 공간이 없음**
- 메모리 관리자가 연속 공간을 요구하는 경우 단편화가 치명적

> JVM에서 GC가 없는 경우, 객체 생성과 삭제가 반복되면 Heap이 쪼개짐 -> 외부 단편화 누적 -> OOM  
> OS에서 malloc/free 반복 시 heap top이 올라가는데, free 된 블록은 재사용 안되면 단편화 심화

### 내부 단편화
- 고정 크기 블록으로만 할당할 경우, 요청보다 큰 블록이 제공되면 낭비 발생
- 페이지 단위 관리(Paging) 시스템의 특징

> 예: 1.5KB 요청 -> 4KB 페이지 할당 -> 2.5KB 낭비  
> JVM의 TLAB(Thread Local Allocation Buffer)는 성능 향상을 위해 고정 크기 블록을 각 스레드에 제공하는데, 이때도 내부 단편화 가능


## 해결 방법

### 외부 단편화 해결
| 방법                          | 설명                                                    | JVM 적용 사례                                                |
| --------------------------- | ----------------------------------------------------- | -------------------------------------------------------- |
| **Compaction (압축)**         | 사용 중인 객체를 한쪽으로 몰아 빈 공간을 정리 → 연속된 공간 확보                | `Serial GC`, `CMS`, `G1 GC`, `ZGC` 등의 GC에서 Compact 단계 존재 |
| **Generational GC**         | 객체를 **영역별로 나눠 관리**하여 fragment가 덜 생기게 함 (Young/Old 구분) | 대부분의 JVM GC에서 세대 분리                                      |
| **Region-based Allocation** | 고정된 크기의 메모리 Region으로 나눠서, 조각이 생겨도 Region 단위로 이동       | G1 GC, Shenandoah GC 등                                   |
| **메모리 풀 (Object Pooling)**  | 객체를 생성/파괴하지 않고 재사용하여 단편화 방지                           | Netty, Spring에서 커넥션 풀 등 활용                               |


### 내부 단편화 해결
| 방법                         | 설명                                        | JVM/OS 관점 예시                             |
| -------------------------- | ----------------------------------------- | ---------------------------------------- |
| **슬랩 할당자(Slab Allocator)** | 비슷한 크기의 객체를 **슬랩이라는 그룹**으로 묶어 미리 할당하고 재사용 | JVM 내부에서 `Arena allocator`, OS 커널 메모리 관리 |
| **가변 크기 할당 전략**            | 다양한 크기의 블록을 관리하고, 필요한 만큼만 할당 (Best-fit 등) | Custom memory allocator 사용 시 적용 가능       |
| **TLAB 최적화**               | Thread별 고정 블록인 TLAB 크기를 동적으로 조절           | JVM 옵션: `-XX:+ResizeTLAB`                |


## JVM과의 관계
| 요소                                        | 설명                                                                          |
| ----------------------------------------- | --------------------------------------------------------------------------- |
| **Heap 메모리**                              | 객체가 생성되고 사라지면서 단편화 발생 가능                                                    |
| **Garbage Collector**                     | `Mark → Sweep → Compact` 전략으로 외부 단편화 해결                                     |
| **TLAB (Thread Local Allocation Buffer)** | 각 스레드가 사용하는 고정 크기 버퍼. 내부 단편화 가능성 있음                                         |
| **G1 GC, ZGC, Shenandoah GC**             | Region 단위로 분할하여 단편화 문제 최소화                                                  |
| **Metaspace**                             | Java 8 이후 Permanent Generation 제거. Native 영역으로 옮겨 별도 관리됨. 이 영역에서도 단편화 고려 대상 |

## 예시

### 외부 단편화 예시

```text
[###][   ][##][   ][#][     ]
 ↑      ↑   ↑       ↑    ↑
객체1  빈공간 객체2  객체3 빈공간 ... → 10칸짜리 객체 못 들어감!
```

### 내부 단편화 예시

```text
사용자 요청: 3KB → OS 할당: 4KB → 낭비: 1KB
JVM TLAB: 512KB 할당 → 200KB만 사용 → 낭비: 312KB
```

## JVM GC 전략 요약 (단편화 대응)
| GC               | 단편화 해결 방식                              |
| ---------------- | -------------------------------------- |
| Serial GC        | Stop-the-world 후 Compact               |
| Parallel GC      | Compact 수행                             |
| CMS              | 기본적으로 Compact 안 함 → 단편화 문제 발생 가능       |
| G1 GC            | Region 단위 이동으로 단편화 줄임                  |
| ZGC / Shenandoah | GC 중에도 객체 이동 → 단편화 자동 해소 (Low-latency) |
