# 메모리 단편화 (Memory Fragmentation)

## 정의
**메모리 단편화**란, 메모리 전체 공간은 충분히 있지만 **연속적인 할당이 불가능한 상태**를 의미한다.  
이로 인해 시스템은 더 이상 메모리를 **효율적으로 할당하지 못하고**, 성능 저하 혹은 OOM(OutOfMemory)이 발생할 수 있다.

> 핵심:  
> 전체 공간은 넉넉한데, **조각나 있어서** 큰 덩어리를 못 넣는 상황

## 단편화의 종류
| 구분                                  | 설명                                                       | 비유                                    | JVM/OS 관점 예시                                                                                |
| ----------------------------------- | -------------------------------------------------------- | ------------------------------------- | ------------------------------------------------------------------------------------------- |
| **외부 단편화 (External Fragmentation)** | 메모리 해제 후 남은 빈 공간들이 서로 떨어져 있어서 연속된 큰 블록 할당이 어려운 상태        | 서랍에 여러 칸이 비어있지만, 큰 책을 넣을 만한 연속된 칸이 없음 | JVM에서 객체들이 생겼다 사라지면서 heap에 빈 공간이 흩어짐. 특히 `Mark-Sweep` 단계 후 `Compact`를 하지 않으면 발생             |
| **내부 단편화 (Internal Fragmentation)** | 고정된 크기의 블록을 할당했지만, 실제 필요한 양보다 크게 할당되어 **남는 공간이 낭비**되는 상태 | 1리터 생수통에 600ml만 넣은 경우, 400ml는 낭비됨     | 4KB 페이지 할당 단위로 OS가 관리할 때, 1KB만 써도 3KB는 낭비됨. JVM의 `Thread Stack`, `TLAB` 같은 고정 크기 구조에서 발생 가능 |

## 단편화가 발생하는 이유

### 외부 단편화
- 동적 메모리 할당/해제가 반복되며 빈 공간이 생김
- 할당할 수 있는 공간은 존재하나 **요청 크기만큼 연속된 공간이 없음**
- 메모리 관리자가 연속 공간을 요구하는 경우 단편화가 치명적

> 예시 (OS):  
> A(100KB) → B(200KB) → C(100KB)  
> B 해제 후, 300KB 요청 → 연속된 공간 없음 → 실패

> JVM 예시:  
> 객체 생성/삭제 반복 → Heap 공간 흩어짐 → GC가 compact 하지 않으면 외부 단편화 누적

### 내부 단편화
- 고정 크기 블록으로만 할당할 경우, 요청보다 큰 블록이 제공되면 낭비 발생
- 페이지 단위 관리(Paging) 시스템의 특징

> 예시 (OS):  
> 1.5KB 요청 → 4KB 페이지 할당 → 2.5KB 낭비

> JVM 예시:  
> TLAB 512KB 할당 후 실제 200KB만 사용 → 312KB 낭비

## 해결 방법

### 외부 단편화 해결
| 방법                          | 설명                                                    | JVM 적용 사례                                                |
| --------------------------- | ----------------------------------------------------- | -------------------------------------------------------- |
| **Compaction (압축)**         | 사용 중인 객체를 한쪽으로 몰아 빈 공간을 정리 → 연속된 공간 확보                | `Serial GC`, `CMS`, `G1 GC`, `ZGC` 등의 GC에서 Compact 단계 존재 |
| **Generational GC**         | 객체를 **영역별로 나눠 관리**하여 fragment가 덜 생기게 함 (Young/Old 구분) | 대부분의 JVM GC에서 세대 분리                                      |
| **Region-based Allocation** | 고정된 크기의 메모리 Region으로 나눠서, 조각이 생겨도 Region 단위로 이동       | G1 GC, Shenandoah GC 등                                   |
| **메모리 풀 (Object Pooling)**  | 객체를 생성/파괴하지 않고 재사용하여 단편화 방지                           | Netty, Spring에서 커넥션 풀 등 활용                               |


### 내부 단편화 해결
| 방법                         | 설명                                        | JVM/OS 관점 예시                             |
| -------------------------- | ----------------------------------------- | ---------------------------------------- |
| **슬랩 할당자(Slab Allocator)** | 비슷한 크기의 객체를 **슬랩이라는 그룹**으로 묶어 미리 할당하고 재사용 | JVM 내부에서 `Arena allocator`, OS 커널 메모리 관리 |
| **가변 크기 할당 전략**            | 다양한 크기의 블록을 관리하고, 필요한 만큼만 할당 (Best-fit 등) | Custom memory allocator 사용 시 적용 가능       |
| **TLAB 최적화**               | Thread별 고정 블록인 TLAB 크기를 동적으로 조절           | JVM 옵션: `-XX:+ResizeTLAB`                |


## JVM과의 관계
| 요소                                        | 설명                                                                          |
| ----------------------------------------- | --------------------------------------------------------------------------- |
| **Heap 메모리**                              | 객체가 생성되고 사라지면서 단편화 발생 가능                                                    |
| **Garbage Collector**                     | `Mark → Sweep → Compact` 전략으로 외부 단편화 해결                                     |
| **TLAB (Thread Local Allocation Buffer)** | 각 스레드가 사용하는 고정 크기 버퍼. 내부 단편화 가능성 있음                                         |
| **G1 GC, ZGC, Shenandoah GC**             | Region 단위로 분할하여 단편화 문제 최소화                                                  |
| **Metaspace**                             | Java 8 이후 Permanent Generation 제거. Native 영역으로 옮겨 별도 관리됨. 이 영역에서도 단편화 고려 대상 |

## 예시

### 외부 단편화 예시

```text
[###][   ][##][   ][#][     ]
 ↑      ↑   ↑       ↑    ↑
객체1  빈공간 객체2  객체3 빈공간 ... → 10칸짜리 객체 못 들어감!
```

### 내부 단편화 예시

```text
사용자 요청: 3KB → OS 할당: 4KB → 낭비: 1KB
JVM TLAB: 512KB 할당 → 200KB만 사용 → 낭비: 312KB
```

## 페이징(Paging)과 단편화

### Paging이 외부 단편화를 막는 방식
- 가상 주소 공간과 실제 물리 주소를 분리
- **연속된 가상 메모리**가 실제 메모리 상에서는 **비연속적으로 저장**
- 외부 단편화를 OS 수준에서는 거의 제거함

### 하지만 내부 단편화는 발생
- 운영체제는 일반적으로 고정된 크기의 페이지(예: 4KB) 단위로 메모리를 관리한다.
- 이 때문에 요청한 메모리 크기가 페이지 크기보다 작을 경우,  
  남는 공간은 다른 프로세스나 요청이 재사용할 수 없어 낭비된다.
- 예: 3KB 요청 → 4KB 페이지 하나 사용 → 남은 1KB는 사용 불가 → 내부 단편화 발생


## JVM GC 전략 요약 (단편화 대응)
| GC               | 단편화 해결 방식                              |
| ---------------- | -------------------------------------- |
| Serial GC        | Stop-the-world 후 Compact               |
| Parallel GC      | Compact 수행                             |
| CMS              | 기본적으로 Compact 안 함 → 단편화 문제 발생 가능       |
| G1 GC            | Region 단위 이동으로 단편화 줄임                  |
| ZGC / Shenandoah | GC 중에도 객체 이동 → 단편화 자동 해소 (Low-latency) |


## 결론 및 요약
- **외부 단편화**는 조각난 빈 공간 문제, **내부 단편화**는 고정 단위로 인한 낭비 문제
- OS는 `malloc/free`, 페이징, 슬랩 할당자 등 다양한 전략이로 이를 해결
- JVM의 GC 또한 OS에서 사용하는 **단편화 해결 전략을 차용**해 설계됨